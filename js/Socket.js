// Generated by CoffeeScript 1.10.0
(function() {
  var bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  define(['paper', 'R', 'Utils/Utils', 'socket.ioID', 'i18next'], function(P, R, Utils, ioo, i18next) {
    var Socket;
    Socket = (function() {
      function Socket() {
        this.onDrawEnd = bind(this.onDrawEnd, this);
        this.onDrawUpdate = bind(this.onDrawUpdate, this);
        this.onDrawBegin = bind(this.onDrawBegin, this);
        this.fadeTailsInterval = bind(this.fadeTailsInterval, this);
        this.onSetUserName = bind(this.onSetUserName, this);
        this.startChatting = bind(this.startChatting, this);
        this.updateRoom = bind(this.updateRoom, this);
        this.sendMessage = bind(this.sendMessage, this);
        this.submitChatUserName = bind(this.submitChatUserName, this);
        this.onConnectionError = bind(this.onConnectionError, this);
        this.onKeyPress = bind(this.onKeyPress, this);
        this.addMessage = bind(this.addMessage, this);
        this.connectToTipibot = bind(this.connectToTipibot, this);
        this.initialize();
        return;
      }

      Socket.prototype.emit = function() {
        this.socket.emit.apply(this.socket, arguments);
      };

      Socket.prototype.initialize = function() {
        this.userToPaths = new Map();
        this.userToColor = new Map();
        this.fadeTailsIntervalID = null;
        this.chatJ = $("#chatContent");
        this.chatMainJ = this.chatJ.find("#chatMain");
        this.chatRoomJ = this.chatMainJ.find("#chatRoom");
        this.chatUsernamesJ = this.chatMainJ.find("#chatUserNames");
        this.chatMessagesJ = this.chatMainJ.find("#chatMessages");
        this.chatMessageJ = this.chatMainJ.find("#chatSendMessageInput");
        this.chatMessageJ.blur();
        if (R.offline) {
          this.socket = {
            emit: function() {}
          };
          return;
        }
        this.socket = io.connect("/chat");
        this.socket.on("connect", this.updateRoom);
        this.socket.on("announcement", this.addMessage);
        this.socket.on("nicknames", (function(_this) {
          return function(nicknames) {
            var i;
            console.log('nicknames');
            _this.chatUsernamesJ.empty().append("<span data-i18n='Online'>" + i18next.t('Online') + "</span>: ");
            for (i in nicknames) {
              _this.chatUsernamesJ.append($("<b>").text(i > 0 ? ', ' + nicknames[i] : nicknames[i]));
            }
          };
        })(this));
        this.socket.on("msg_to_room", (function(_this) {
          return function(from, msg) {
            _this.addMessage(msg, from);
          };
        })(this));
        this.socket.on("reconnect", (function(_this) {
          return function() {
            console.log('reconnect');
            _this.chatMessagesJ.remove();
            _this.addMessage("Reconnected to the server", "System");
          };
        })(this));
        this.socket.on("reconnecting", (function(_this) {
          return function() {
            console.log('reconnecting');
            _this.addMessage("Attempting to re-connect to the server", "System");
          };
        })(this));
        this.socket.on("error", (function(_this) {
          return function(e) {
            console.log('error');
            console.log(e);
            _this.addMessage((e ? e : "A unknown error occurred"), "System");
          };
        })(this));
        this.chatMainJ.find("#chatSendMessageSubmit").click(this.sendMessage);
        this.chatMessageJ.keypress(this.onKeyPress);
        this.chatConnectionTimeout = setTimeout(this.onConnectionError, 2000);
        if (R.userAuthenticated) {
          this.startChatting(R.me);
        } else {
          this.initializeUserName();
        }
        this.socket.on("bounce", this.onBounce);
        this.socket.on("drawing change", this.onDrawingChange);
        this.socket.on("draw begin", this.onDrawBegin);
        this.socket.on("draw update", this.onDrawUpdate);
        this.socket.on("draw end", this.onDrawEnd);
        if (R.tipibot) {
          setTimeout(this.connectToTipibot, 3000);
        }
      };

      Socket.prototype.connectToTipibot = function() {
        console.log('connect to tipibot...');
        this.tipibotSocket = new WebSocket("ws://localhost:8026/tipibot");
        this.tipibotSocket.onopen = function(event) {
          console.log('tipibotSocket.onopen', event);
        };
        this.tipibotSocket.onmessage = (function(_this) {
          return function(event) {
            var args, message;
            console.log(event.data);
            message = JSON.parse(event.data);
            switch (message.type) {
              case 'getNextValidatedDrawing':
                if (R.loader.drawingPaths.length === 0) {
                  if (!_this.requestedNextDrawing) {
                    args = {
                      cityName: R.city.name
                    };
                    $.ajax({
                      method: "POST",
                      url: "ajaxCall/",
                      data: {
                        data: JSON.stringify({
                          "function": 'getNextValidatedDrawing',
                          args: args
                        })
                      }
                    }).done(function(results) {
                      _this.requestedNextDrawing = false;
                      if (results.message === 'no path') {
                        return;
                      }
                      R.loader.loadCallbackTipibot(results);
                    });
                    _this.requestedNextDrawing = true;
                  }
                } else {
                  R.loader.sendNextPathsToTipibot();
                }
                break;
              case 'setDrawingStatusDrawn':
                if (R.loader.drawingPaths.length === 0) {
                  args = {
                    pk: message.pk,
                    secret: message.secret
                  };
                  $.ajax({
                    method: "POST",
                    url: "ajaxCall/",
                    data: {
                      data: JSON.stringify({
                        "function": 'setDrawingStatusDrawn',
                        args: args
                      })
                    }
                  }).done(function(results) {
                    if (!R.loader.checkError(results)) {
                      return;
                    }
                    R.socket.tipibotSocket.send(JSON.stringify({
                      type: 'drawingStatusSetToDrawn',
                      drawingPk: results.pk
                    }));
                  });
                } else {
                  R.socket.tipibotSocket.send(JSON.stringify({
                    type: 'drawingStatusSetToDrawn',
                    drawingPk: message.pk
                  }));
                }
            }
          };
        })(this);
      };

      Socket.prototype.initializeUserName = function() {
        var adjectives, things, username, usernameJ;
        this.chatJ.find("a.sign-in").click(this.onSignInClick);
        this.chatJ.find("a.change-username").click(this.onChangeUserNameClick);
        usernameJ = this.chatJ.find("#chatUserName");
        usernameJ.find('#chatUserNameInput').keypress(this.onUserNameInputKeypress);
        usernameJ.find("#chatUserNameSubmit").submit(this.submitChatUserName);
        adjectives = ["Cool", "Masked", "Bloody", "Super", "Mega", "Giga", "Ultra", "Big", "Blue", "Black", "White", "Red", "Purple", "Golden", "Silver", "Dangerous", "Crazy", "Fast", "Quick", "Little", "Funny", "Extreme", "Awsome", "Outstanding", "Crunchy", "Vicious", "Zombie", "Funky", "Sweet"];
        things = ["Hamster", "Moose", "Lama", "Duck", "Bear", "Eagle", "Tiger", "Rocket", "Bullet", "Knee", "Foot", "Hand", "Fox", "Lion", "King", "Queen", "Wizard", "Elephant", "Thunder", "Storm", "Lumberjack", "Pistol", "Banana", "Orange", "Pinapple", "Sugar", "Leek", "Blade"];
        username = Utils.Array.random(adjectives) + " " + Utils.Array.random(things);
        this.submitChatUserName(username, false);
      };

      Socket.prototype.addMessage = function(message, from) {
        var author;
        if (from == null) {
          from = null;
        }
        if (from != null) {
          author = from === R.me ? "me" : from;
          this.chatMessagesJ.append($("<p>").append($("<b>").text(author + ": "), message));
        } else {
          this.chatMessagesJ.append($("<p data-i18n='" + message + "'>").append(i18next.t(message)));
        }
        this.chatMessageJ.val('');
      };

      Socket.prototype.onKeyPress = function(event) {
        if (event.which === 13) {
          event.preventDefault();
          this.sendMessage();
        }
      };

      Socket.prototype.onConnectionError = function() {
        var error;
        error = "Impossible to connect to chat";
        this.chatMainJ.find("#chatConnectingMessage").attr('data-i18n', error).text(i18next.t(error));
      };

      Socket.prototype.onSignInClick = function(event) {
        $("#user-login-group > button").click();
        event.preventDefault();
        return false;
      };

      Socket.prototype.onChangeUserNameClick = function(event) {
        $("#chatUserName").show();
        $("#chatUserNameInput").focus();
        event.preventDefault();
        return false;
      };

      Socket.prototype.onUserNameInputKeypress = function(event) {
        if (event.which === 13) {
          event.preventDefault();
          this.submitChatUserName();
        }
      };

      Socket.prototype.submitChatUserName = function(username, focusOnChat) {
        if (focusOnChat == null) {
          focusOnChat = true;
        }
        $("#chatUserName").hide();
        if (username == null) {
          username = usernameJ.find('#chatUserNameInput').val();
        }
        this.startChatting(username, false, focusOnChat);
      };

      Socket.prototype.sendMessage = function() {
        this.socket.emit("user message", this.chatMessageJ.val());
        this.addMessage(this.chatMessageJ.val(), R.me);
      };

      Socket.prototype.updateRoom = function() {
        var room;
        room = this.getChatRoom();
        if (R.room !== room) {
          this.chatRoomJ.empty().append(("<span><span data-i18n='Room'>" + (i18next.t('Room')) + "</span>: </span>") + room);
          this.socket.emit("join", room);
          return R.room = room;
        }
      };

      Socket.prototype.startChatting = function(username, realUsername, focusOnChat) {
        if (realUsername == null) {
          realUsername = true;
        }
        if (focusOnChat == null) {
          focusOnChat = true;
        }
        this.socket.emit("nickname", username, this.onSetUserName);
        if (focusOnChat) {
          this.chatMessageJ.focus();
        }
        if (realUsername) {
          this.chatJ.find("#chatLogin").addClass("hidden");
        } else {
          this.chatJ.find("#chatLogin p.default-username-message").html(("<span data-i18n='You are logged as'>" + (i18next.t('You are logged as')) + "</span> <strong>") + username + "</strong>");
        }
      };

      Socket.prototype.onSetUserName = function(set) {
        if (set) {
          clearTimeout(this.chatConnectionTimeout);
          this.chatMainJ.removeClass("hidden");
          this.chatMainJ.find("#chatConnectingMessage").addClass("hidden");
          this.chatJ.find("#chatUserNameError").addClass("hidden");
        } else {
          this.chatJ.find("#chatUserNameError").removeClass("hidden");
        }
      };

      Socket.prototype.onDrawingChange = function(data) {
        R.drawingPanel.onDrawingChange(data);
      };

      Socket.prototype.fadeTailsInterval = function() {
        var nAlivePaths;
        nAlivePaths = 0;
        this.userToPaths.forEach((function(_this) {
          return function(paths, user) {
            var j, len, path, ref, results1;
            ref = paths.slice();
            results1 = [];
            for (j = 0, len = ref.length; j < len; j++) {
              path = ref[j];
              path.scale(0.9);
              path.position = path.position.add(path.data.direction);
              path.data.lives--;
              path.strokeColor.alpha -= 0.1;
              path.fillColor.alpha -= 0.1;
              if (path.data.lives === 0) {
                path.remove();
                results1.push(paths.splice(paths.indexOf(path), 1));
              } else {
                results1.push(nAlivePaths++);
              }
            }
            return results1;
          };
        })(this));
        if (nAlivePaths === 0) {
          clearInterval(this.fadeTailsIntervalID);
          this.fadeTailsIntervalID = null;
        }
      };

      Socket.prototype.createPath = function(point, color) {
        var path;
        path = new P.Path.Circle(point, 3);
        path.strokeColor = color;
        path.fillColor = color;
        path.strokeColor.alpha = 1;
        path.fillColor.alpha = 1;
        path.data.direction = P.Point.random().subtract(0.5).multiply(3);
        path.strokeCap = 'round';
        path.strokeJoin = 'round';
        path.data.lives = 10;
        return path;
      };

      Socket.prototype.onDrawBegin = function(user, point) {
        var color, path, paths;
        if (user === R.me) {
          return;
        }
        paths = this.userToPaths.get(user);
        if (paths == null) {
          paths = [];
          this.userToPaths.set(user, paths);
        }
        color = this.userToColor.get(user);
        if (color == null) {
          color = new P.Color({
            hue: Math.floor(Math.random() * 360 / 10) * 10,
            saturation: 0.35,
            brightness: 0.95
          });
        }
        this.userToColor.set(user, color);
        path = this.createPath(point, color);
        paths.push(path);
        if (!this.fadeTailsIntervalID) {
          this.fadeTailsIntervalID = setInterval(this.fadeTailsInterval, 100);
        }
      };

      Socket.prototype.onDrawUpdate = function(user, point) {
        var path, paths;
        if (user === R.me) {
          return;
        }
        paths = this.userToPaths.get(user);
        if (paths != null) {
          path = this.createPath(point, this.userToColor.get(user));
          paths.push(path);
        }
      };

      Socket.prototype.onDrawEnd = function(user, point) {
        if (user === R.me) {
          return;
        }
      };

      Socket.prototype.onBounce = function(data) {
        var allowedFunctions, id, item, itemClass, itemMustBeRasterized, rFunction, ref, ref1, ref2, ref3, tool;
        if (R.ignoreSockets) {
          return;
        }
        if ((data["function"] != null) && (data["arguments"] != null)) {
          if (data.tool != null) {
            tool = R.tools[data.tool];
            if ((ref = data["function"]) !== 'begin' && ref !== 'update' && ref !== 'end' && ref !== 'createPath') {
              console.log('Error: not authorized to call' + data["function"]);
              return;
            }
            rFunction = tool != null ? tool[data["function"]] : void 0;
            if (rFunction != null) {
              rFunction.apply(tool, data["arguments"]);
            }
          } else if (data.itemId != null) {
            item = R.items[data.itemId];
            if ((item != null) && (item.currentCommand == null)) {
              allowedFunctions = ['setRectangle', 'setRotation', 'moveTo', 'setParameter', 'modifyPoint', 'modifyPointType', 'modifySpeed', 'setPK', 'delete', 'create', 'addPoint', 'deletePoint', 'modifyControlPath', 'setText'];
              if (ref1 = data["function"], indexOf.call(allowedFunctions, ref1) < 0) {
                console.log('Error: not authorized to call: ' + data["function"]);
                return;
              }
              rFunction = item[data["function"]];
              if (rFunction == null) {
                console.log('Error: function is not valid: ' + data["function"]);
                return;
              }
              id = 'rasterizeItem-' + item.od;
              itemMustBeRasterized = ((ref2 = data["function"]) !== 'setPK' && ref2 !== 'create') && !item.drawing.visible;
              item.drawing.visible = true;
              item.socketAction = true;
              rFunction.apply(item, data["arguments"]);
              delete item.socketAction;
              if (itemMustBeRasterized && ((ref3 = data["function"]) !== 'delete')) {
                Utils.deferredExecution(this.rasterizeItem, id, 1000);
              }
            }
          } else if (data.itemClass && data["function"] === 'create') {
            itemClass = g[data.itemClass];
            if (Item.prototype.isPrototypeOf(itemClass)) {
              itemClass.socketAction = true;
              itemClass.create.apply(itemClass, data["arguments"]);
            }
          }
          P.view.update();
        }
      };

      Socket.prototype.rasterizeItem = function() {};

      Socket.prototype.getChatRoom = function() {
        return 'Comme un dessein';
      };

      return Socket;

    })();
    return Socket;
  });

}).call(this);
