// Generated by CoffeeScript 1.10.0
(function() {
  var bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  define(['paper', 'R', 'Utils/Utils', 'UI/Button', 'UI/Modal', 'i18next'], function(P, R, Utils, Button, Modal, i18next) {
    var Tracer;
    Tracer = (function() {
      function Tracer() {
        this.handleFiles = bind(this.handleFiles, this);
        this.fileDropped = bind(this.fileDropped, this);
        this.submitURL = bind(this.submitURL, this);
        this.rasterOnError = bind(this.rasterOnError, this);
        this.rasterOnLoad = bind(this.rasterOnLoad, this);
        this.drawHandles = bind(this.drawHandles, this);
        this.drawCorners = bind(this.drawCorners, this);
        this.drawMoves = bind(this.drawMoves, this);
        this.removeRaster = bind(this.removeRaster, this);
        this.tracerGroup = null;
        this.tracerBtn = null;
        this.createTracerButton();
        this.initializeGlobalDragAndDrop();
        return;
      }

      Tracer.prototype.initializeGlobalDragAndDrop = function() {
        document.body.addEventListener('dragenter', (function(_this) {
          return function(event) {
            event.stopPropagation();
            event.preventDefault();
            R.alertManager.alert('Drop your image here to trace it', 'info');
          };
        })(this));
        document.body.addEventListener('dragover', (function(_this) {
          return function(event) {
            event.stopPropagation();
            event.preventDefault();
          };
        })(this));
        document.body.addEventListener('dragleave', (function(_this) {
          return function(event) {
            event.stopPropagation();
            event.preventDefault();
          };
        })(this));
        document.body.addEventListener('drop', this.fileDropped, false);
      };

      Tracer.prototype.createTracerButton = function() {
        this.tracerBtn = new Button({
          name: 'Trace',
          iconURL: 'new 1/Image.svg',
          classes: 'dark',
          favorite: true,
          category: null,
          disableHover: true,
          popover: true,
          order: null
        });
        this.tracerBtn.hide();
        return this.tracerBtn.btnJ.click((function(_this) {
          return function() {
            var dropZoneJ, inputJ, orText;
            _this.removeRaster();
            _this.modal = Modal.createModal({
              id: 'import-image',
              title: "Import image to trace",
              submit: _this.submitURL
            });
            dropZoneJ = $("<div id=\"modal-dropZone\" style=\"min-height: 200px; white-space: pre; border: 3px dashed gray; text-align: center; padding-top: 85px; margin-bottom: 15px;\"\nondragenter=\"document.getElementById('modal-dropZone').textContent = ''; event.stopPropagation(); event.preventDefault();\"\nondragover=\"event.stopPropagation(); event.preventDefault();\">" + i18next.t('Drop image here') + "</div>");
            dropZoneJ.get(0).addEventListener('drop', _this.fileDropped, false);
            _this.modal.addCustomContent({
              name: 'dropZone',
              divJ: dropZoneJ
            });
            orText = _this.modal.addText('or');
            orText.css({
              'text-align': 'center',
              'margin': 10
            });
            inputJ = $('<input type="file" multiple accept="image/*">');
            _this.modal.addCustomContent({
              name: 'tracerFileInput',
              divJ: inputJ
            });
            inputJ.css({
              margin: 'auto'
            });
            inputJ.get(0).addEventListener('change', _this.handleFiles, false);
            orText = _this.modal.addText('or');
            orText.css({
              'text-align': 'center',
              'margin': 10
            });
            _this.modal.addTextInput({
              name: 'imageURL',
              placeholder: 'http://exemple.fr/belle-image.png',
              type: 'url',
              submitShortcut: true,
              label: 'Import image from URL',
              required: true,
              errorMessage: i18next.t('The URL is invalid')
            });
            _this.modal.show();
          };
        })(this));
      };

      Tracer.prototype.removeRaster = function() {
        var ref, ref1;
        if (this.moves != null) {
          this.moves.remove();
        }
        if (this.corners != null) {
          this.corners.remove();
        }
        if ((ref = this.raster) != null) {
          ref.remove();
        }
        if ((ref1 = this.tracerGroup) != null) {
          ref1.remove();
        }
      };

      Tracer.prototype.drawMoves = function(bounds, size, sign, signRotations, signOffsets) {
        var arrow, base, handle, handlePath, handlePos, handleSize, j, len, pos, ref;
        if (this.moves != null) {
          this.moves.remove();
        }
        this.moves = new P.Group();
        this.tracerGroup.addChild(this.moves);
        ref = ['topCenter', 'rightCenter', 'bottomCenter', 'leftCenter'];
        for (j = 0, len = ref.length; j < len; j++) {
          pos = ref[j];
          handle = new P.Group();
          handle.name = 'handle-move-' + pos;
          handleSize = size.clone();
          if (pos === 'topCenter' || pos === 'bottomCenter') {
            handleSize.width = bounds.width;
          } else {
            handleSize.height = bounds.height;
          }
          handlePos = bounds[pos].subtract(handleSize.divide(2));
          handlePath = new P.Path.Rectangle(handlePos, handleSize);
          handlePath.fillColor = '#42b3f4';
          handlePath.strokeColor = 'white';
          handlePath.strokeWidth = 1;
          handlePath.strokeScaling = false;
          handle.addChild(handlePath);
          arrow = sign.clone();
          arrow.position = bounds[pos].add(signOffsets[pos]);
          arrow.rotation = signRotations[pos];
          handle.addChild(arrow);
          if ((base = this.raster).data == null) {
            base.data = {};
          }
          this.raster.data[pos] = handle;
          handle.applyMatrix = false;
          handle.on('mousedown', (function(_this) {
            return function(event) {
              _this.draggingImage = true;
            };
          })(this));
          handle.on('mousedrag', (function(_this) {
            return function(event) {
              if (!_this.draggingImage) {
                return;
              }
              if (!_this.scalingImage) {
                _this.tracerGroup.position = _this.tracerGroup.position.add(event.delta);
                _this.draggingImage = true;
              }
            };
          })(this));
          handle.on('mouseup', (function(_this) {
            return function(event) {
              _this.draggingImage = false;
            };
          })(this));
          handle.on('mouseenter', (function(_this) {
            return function(event) {
              var ref1;
              if (!((ref1 = R.selectedTool) != null ? ref1.using : void 0)) {
                R.stageJ.css('cursor', 'move');
              }
            };
          })(this));
          handle.on('mouseleave', (function(_this) {
            return function(event) {
              var ref1;
              if ((ref1 = R.selectedTool) != null) {
                ref1.updateCursor();
              }
            };
          })(this));
          this.moves.addChild(handle);
        }
      };

      Tracer.prototype.drawCorners = function(bounds, size, sign, signRotations, signOffsets) {
        var arrow, base, box, cross1, cross2, handle, handlePath, handlePos, j, len, pos, ref;
        if (this.corners != null) {
          this.corners.remove();
        }
        this.corners = new P.Group();
        this.tracerGroup.addChild(this.corners);
        ref = ['topLeft', 'topRight', 'bottomLeft', 'bottomRight'];
        for (j = 0, len = ref.length; j < len; j++) {
          pos = ref[j];
          handle = new P.Group();
          handle.name = 'handle-corner-' + pos;
          handlePos = bounds[pos].subtract(size.divide(2));
          handlePath = new P.Path.Rectangle(handlePos, size);
          handlePath.fillColor = '#42b3f4';
          handlePath.strokeColor = 'white';
          handlePath.strokeWidth = 1;
          handlePath.strokeScaling = false;
          handle.addChild(handlePath);
          box = handlePath.bounds.expand(-15 / P.view.zoom);
          if ((base = this.raster).data == null) {
            base.data = {};
          }
          this.raster.data[pos] = handle;
          if (pos === 'topRight') {
            cross1 = new P.Path();
            cross1.add(box.topLeft);
            cross1.add(box.bottomRight);
            cross1.strokeWidth = 2;
            cross1.strokeScaling = false;
            cross1.strokeColor = 'black';
            handle.addChild(cross1);
            cross2 = new P.Path();
            cross2.add(box.topRight);
            cross2.add(box.bottomLeft);
            cross2.strokeWidth = 2;
            cross2.strokeScaling = false;
            cross2.strokeColor = 'black';
            handle.addChild(cross2);
            handle.on('mousedown', (function(_this) {
              return function() {
                _this.draggingImage = true;
                _this.removeRaster();
              };
            })(this));
            handle.on('mouseenter', (function(_this) {
              return function(event) {
                var ref1;
                if (!((ref1 = R.selectedTool) != null ? ref1.using : void 0)) {
                  R.stageJ.css('cursor', 'default');
                }
              };
            })(this));
            handle.on('mouseleave', (function(_this) {
              return function(event) {
                var ref1;
                if ((ref1 = R.selectedTool) != null) {
                  ref1.updateCursor();
                }
              };
            })(this));
          } else {
            arrow = sign.clone();
            arrow.position = bounds[pos];
            arrow.rotation = signRotations[pos];
            handle.addChild(arrow);
            handle.on('mousedown', (function(_this) {
              return function(event) {
                _this.draggingImage = true;
                _this.scalingImage = true;
              };
            })(this));
            handle.on('mousedrag', (function(_this) {
              return function(event) {
                var center, i, k, len1, newLength, previousLength, ref1;
                if (!_this.draggingImage) {
                  return;
                }
                center = bounds.center;
                previousLength = event.point.subtract(event.delta).getDistance(center);
                newLength = event.point.getDistance(center);
                bounds = _this.raster.bounds.expand(size);
                _this.drawMoves(bounds, size, sign, signRotations, signOffsets);
                _this.raster.scaling = _this.raster.scaling.multiply(newLength / previousLength);
                ref1 = ['topLeft', 'topRight', 'bottomRight', 'bottomLeft'];
                for (i = k = 0, len1 = ref1.length; k < len1; i = ++k) {
                  pos = ref1[i];
                  _this.raster.data[pos].position = bounds[pos];
                }
                _this.corners.bringToFront();
              };
            })(this));
            handle.on('mouseup', (function(_this) {
              return function(event) {
                _this.draggingImage = false;
                _this.scalingImage = false;
              };
            })(this));
            handle.on('mouseenter', (function(_this) {
              return function(event) {
                var ref1, vector;
                if (!((ref1 = R.selectedTool) != null ? ref1.using : void 0)) {
                  vector = bounds.center.subtract(event.point);
                  R.stageJ.css('cursor', vector.x > 0 && vector.y < 0 ? 'nesw-resize' : 'nwse-resize');
                }
              };
            })(this));
            handle.on('mouseleave', (function(_this) {
              return function(event) {
                var ref1;
                if ((ref1 = R.selectedTool) != null) {
                  ref1.updateCursor();
                }
              };
            })(this));
          }
          this.corners.addChild(handle);
        }
      };

      Tracer.prototype.drawHandles = function() {
        var bounds, sign, signOffsets, signRotations, size;
        if (this.tracerGroup == null) {
          return;
        }
        size = new paper.Size(30 / P.view.zoom, 30 / P.view.zoom);
        bounds = this.raster.bounds.expand(size);
        sign = new P.Path();
        sign.add(12 / P.view.zoom, 0);
        sign.add(0, 0);
        sign.add(0, 12 / P.view.zoom);
        sign.strokeWidth = 2;
        sign.strokeColor = 'black';
        sign.strokeScaling = false;
        sign.pivot = new paper.Point(6 / P.view.zoom, 6 / P.view.zoom);
        sign.remove();
        signRotations = {
          'topCenter': 45,
          'rightCenter': 45 + 90,
          'bottomCenter': 45 + 90 + 90,
          'leftCenter': -45,
          'topRight': 90,
          'topLeft': 0,
          'bottomLeft': -90,
          'bottomRight': 180
        };
        signOffsets = {
          'topCenter': new paper.Point(0, 4 / P.view.zoom),
          'rightCenter': new paper.Point(-4 / P.view.zoom, 0),
          'bottomCenter': new paper.Point(0, -4 / P.view.zoom),
          'leftCenter': new paper.Point(4 / P.view.zoom, 0)
        };
        this.drawMoves(bounds, size, sign, signRotations, signOffsets);
        this.drawCorners(bounds, size, sign, signRotations, signOffsets);
      };

      Tracer.prototype.rasterOnLoad = function(event) {
        var viewBounds;
        R.loader.hideLoadingBar();
        viewBounds = R.view.getViewBounds();
        this.raster.position = viewBounds.center;
        if (this.raster.bounds.width > viewBounds.width) {
          this.raster.scaling = new paper.Point(viewBounds.width / (this.raster.bounds.width + this.raster.bounds.width * 0.25));
        }
        if (this.raster.bounds.height > viewBounds.height) {
          this.raster.scaling = this.raster.scaling.multiply(viewBounds.height / (this.raster.bounds.height + this.raster.bounds.height * 0.25));
        }
        this.raster.applyMatrix = false;
        this.drawHandles();
      };

      Tracer.prototype.rasterOnError = function(event) {
        R.loader.hideLoadingBar();
        this.removeRaster();
        R.alertManager.alert('Could not load the image', 'error');
      };

      Tracer.prototype.submitURL = function(data) {
        this.removeRaster();
        this.tracerGroup = new P.Group();
        this.tracerGroup.opacity = 0.5;
        this.raster = new P.Raster(data.imageURL);
        this.tracerGroup.addChild(this.raster);
        this.raster.position = R.view.getViewBounds().center;
        R.loader.showLoadingBar();
        R.view.selectionLayer.addChild(this.tracerGroup);
        this.raster.onError = this.rasterOnError;
        this.raster.onLoad = this.rasterOnLoad;
      };

      Tracer.prototype.fileDropped = function(event) {
        var file, j, len, reader, ref, ref1;
        event.stopPropagation();
        event.preventDefault();
        if (R.selectedTool !== R.tools['Precise path']) {
          R.tools['Precise path'].select();
        }
        if (R.selectedTool !== R.tools['Precise path']) {
          return;
        }
        ref = event.dataTransfer.files;
        for (j = 0, len = ref.length; j < len; j++) {
          file = ref[j];
          if (file.type.match(/image.*/)) {
            reader = new FileReader();
            if ((ref1 = this.modal) != null) {
              ref1.hide();
            }
            reader.onload = (function(_this) {
              return function(readerEvent) {
                _this.submitURL({
                  imageURL: readerEvent.target.result
                });
              };
            })(this);
            reader.readAsDataURL(file);
          }
        }
      };

      Tracer.prototype.handleFiles = function(event) {
        var file, j, len, reader, ref;
        ref = event.target.files;
        for (j = 0, len = ref.length; j < len; j++) {
          file = ref[j];
          if (file.type.match(/image.*/)) {
            reader = new FileReader();
            this.modal.hide();
            reader.onload = (function(_this) {
              return function(readerEvent) {
                _this.submitURL({
                  imageURL: readerEvent.target.result
                });
              };
            })(this);
            reader.readAsDataURL(file);
          }
          return;
        }
      };

      Tracer.prototype.showButton = function() {
        var ref;
        return (ref = this.tracerBtn) != null ? ref.show() : void 0;
      };

      Tracer.prototype.hideButton = function() {
        var ref;
        return (ref = this.tracerBtn) != null ? ref.hide() : void 0;
      };

      Tracer.prototype.hide = function() {
        var ref;
        return (ref = this.tracerGroup) != null ? ref.visible = false : void 0;
      };

      Tracer.prototype.show = function() {
        var ref;
        return (ref = this.tracerGroup) != null ? ref.visible = true : void 0;
      };

      Tracer.prototype.mouseUp = function(event) {
        var ref;
        this.draggingImage = false;
        this.scalingImage = false;
        if ((ref = R.selectedTool) != null) {
          ref.updateCursor();
        }
      };

      Tracer.prototype.update = function() {
        this.drawHandles();
      };

      return Tracer;

    })();
    return Tracer;
  });

}).call(this);
