// Generated by CoffeeScript 1.10.0
(function() {
  var bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  define(['paper', 'R', 'Utils/Utils', 'UI/Modal', 'potrace', 'i18next'], function(P, R, Utils, Modal, potrace, i18next) {
    var Vectorizer;
    Vectorizer = (function() {
      function Vectorizer() {
        this.onFrame = bind(this.onFrame, this);
        this.startAnimation = bind(this.startAnimation, this);
        this.createPaperProject = bind(this.createPaperProject, this);
        this.strokeWidth = 10;
        return;
      }

      Vectorizer.prototype.createPaperProject = function() {
        var child, i, len, mainProject, ref, stroke, svgCanvas, svgContainer;
        svgContainer = document.getElementById('vectorizer-svg');
        svgContainer.style.display = 'inline-block';
        mainProject = P.project;
        this.width = window.innerWidth;
        this.height = window.innerHeight;
        svgCanvas = document.createElement("canvas");
        svgCanvas.width = this.width;
        svgCanvas.height = this.height;
        svgContainer.appendChild(svgCanvas);
        this.project = new P.Project(svgCanvas);
        this.project.importSVG(Potrace.getSVG(1));
        this.project.activeLayer.scale(2);
        this.project.view.setCenter(this.project.activeLayer.bounds.center);
        this.project.view.onClick = (function(_this) {
          return function(event) {
            var hitResult;
            hitResult = _this.project.hitTest(event.point);
            window.item = hitResult.item;
          };
        })(this);
        this.imageData = null;
        this.compoundPath = this.project.activeLayer.firstChild.firstChild;
        this.strokes = new P.Group();
        ref = this.compoundPath.children;
        for (i = 0, len = ref.length; i < len; i++) {
          child = ref[i];
          stroke = child.clone();
          stroke.fillColor = null;
          stroke.closed = false;
          stroke.strokeColor = 'blue';
          stroke.opacity = 0.5;
          this.strokes.addChild(stroke);
        }
        this.strokes.strokeWidth = 7;
        this.currentPathIndex = 1;
        this.currentOffsetOnPath = 0;
        this.currentLine = null;
        this.currentLines = new P.Group();
        this.currentCircles = [];
      };

      Vectorizer.prototype.setStrokesOpacity = function(opacity) {
        var child, i, len, ref;
        ref = this.strokes.children;
        for (i = 0, len = ref.length; i < len; i++) {
          child = ref[i];
          child.opacity = opacity;
        }
      };

      Vectorizer.prototype.getColorAt = function(point, log) {
        var a, b, g, index, pointInView, r;
        if (log == null) {
          log = false;
        }
        pointInView = this.project.view.projectToView(point).multiply(this.project.view.pixelRatio);
        index = Math.floor(pointInView.x + Math.floor(pointInView.y) * this.width * this.project.view.pixelRatio);
        r = this.imageData.data[4 * index + 0];
        g = this.imageData.data[4 * index + 1];
        b = this.imageData.data[4 * index + 2];
        a = this.imageData.data[4 * index + 3];
        if (log) {
          console.log(pointInView, r, g, b, a);
        }
        return a;
      };

      Vectorizer.prototype.startAnimation = function() {
        var context;
        context = this.project.view.element.getContext('2d');
        this.imageData = context.getImageData(0, 0, this.project.view.pixelRatio * this.width, this.project.view.pixelRatio * this.height);
        this.project.view.onFrame = this.onFrame;
        this.project.view.onMouseMove = (function(_this) {
          return function(event) {
            _this.getColorAt(event.point, true);
          };
        })(this);
        this.project.view.onMouseUp = (function(_this) {
          return function(event) {
            context = _this.project.view.element.getContext('2d');
            _this.imageData = context.getImageData(0, 0, _this.project.view.pixelRatio * _this.width, _this.project.view.pixelRatio * _this.height);
            _this.getColorAt(event.point, true);
          };
        })(this);
      };

      Vectorizer.prototype.onFrame = function() {
        var closestCrossing, crossing, crossings, d, i, j, len, len1, location, midPoint, minDistance, normalSegment, path, ref, strokeWidth;
        if (this.currentPathIndex >= this.compoundPath.children) {
          return;
        }
        path = this.compoundPath.children[this.currentPathIndex];
        location = path.getLocationAt(this.currentOffsetOnPath);
        ref = [-this.strokeWidth, this.strokeWidth];
        for (i = 0, len = ref.length; i < len; i++) {
          strokeWidth = ref[i];
          normalSegment = new P.Path();
          normalSegment.add(location.point);
          normalSegment.add(location.point.add(location.normal.multiply(strokeWidth)));
          normalSegment.strokeColor = 'yellow';
          normalSegment.strokeWidth = 1;
          crossings = this.compoundPath.getCrossings(normalSegment);
          normalSegment.remove();
          closestCrossing = null;
          minDistance = Number.MAX_VALUE;
          for (j = 0, len1 = crossings.length; j < len1; j++) {
            crossing = crossings[j];
            d = crossing.point.getDistance(location.point, true);
            if (d > 0 && d < minDistance) {
              closestCrossing = crossing;
              minDistance = d;
            }
          }
          if (closestCrossing) {
            midPoint = closestCrossing.point.add(location.point).divide(2);
            if (this.getColorAt(midPoint) < 128) {
              if (this.currentLine == null) {
                this.currentLine = new P.Path();
                this.currentLine.strokeColor = 'orange';
                this.currentLine.strokeWidth = 5;
                this.currentLine.strokeCap = 'round';
                this.currentLine.strokeJoin = 'round';
                this.currentLines.addChild(this.currentLine);
              }
              this.currentLine.add(midPoint);
            }
          }
        }
        this.currentOffsetOnPath += 10;
        if (this.currentOffsetOnPath > path.length) {
          this.currentOffsetOnPath = 0;
          this.currentPathIndex++;
          if (this.currentPathIndex >= this.compoundPath.children) {
            this.compoundPath.remove();
          }
          this.currentLine = null;
        }
      };

      Vectorizer.prototype.vectorize = function(imageFile, imageURL, C, windowSize) {
        console.log(C, windowSize);
        Potrace.setParameter({
          adaptiveThresholdC: C,
          adaptiveThresholdWindowSize: windowSize
        });
        if (imageFile != null) {
          Potrace.loadImageFromFile(imageFile);
        } else if (imageURL != null) {
          Potrace.loadImageFromUrl(imageURL);
        } else {
          return;
        }
        Potrace.process(this.createPaperProject);
      };

      return Vectorizer;

    })();
    return Vectorizer;
  });

}).call(this);
