// Generated by CoffeeScript 1.10.0
(function() {
  var bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  define(['paper', 'R', 'Utils/Utils', 'Tools/Tool', 'Commands/Command', 'UI/Button', 'i18next'], function(P, R, Utils, Tool, Command, Button, i18next) {
    var PathTool;
    PathTool = (function(superClass) {
      extend(PathTool, superClass);

      PathTool.label = '';

      PathTool.description = '';

      PathTool.iconURL = '';

      PathTool.buttonClasses = 'displayName btn-success';

      PathTool.cursor = {
        position: {
          x: 0,
          y: 32
        },
        name: 'crosshair',
        icon: R.style === 'line' ? 'mouse_draw' : null
      };

      PathTool.drawItems = true;

      PathTool.emitSocket = false;

      PathTool.maxDraftSize = 500;

      PathTool.computeDraftBounds = function(paths) {
        var bounds, ref;
        if (paths == null) {
          paths = null;
        }
        bounds = (ref = R.Drawing.getDraft()) != null ? ref.getBounds() : void 0;
        return bounds;
      };

      PathTool.draftIsTooBig = function(paths, tolerance) {
        var draftBounds;
        if (paths == null) {
          paths = null;
        }
        if (tolerance == null) {
          tolerance = 0;
        }
        draftBounds = this.computeDraftBounds(paths);
        console.log(draftBounds);
        return this.draftBoundsIsTooBig(draftBounds, tolerance);
      };

      PathTool.draftBoundsIsTooBig = function(draftBounds, tolerance) {
        if (tolerance == null) {
          tolerance = 0;
        }
        return (draftBounds != null) && draftBounds.width > this.maxDraftSize * R.city.pixelPerMm - tolerance || draftBounds.height > this.maxDraftSize * R.city.pixelPerMm - tolerance;
      };

      PathTool.displayDraftIsTooBigError = function() {
        R.alertManager.alert('Your drawing is too big', 'error');
      };

      function PathTool(Path, justCreated) {
        this.Path = Path;
        if (justCreated == null) {
          justCreated = false;
        }
        this.animateCircleBackup = bind(this.animateCircleBackup, this);
        this.name = this.Path.label;
        this.constructor.label = this.name;
        if (this.Path.description) {
          this.constructor.description = this.Path.rdescription;
        }
        if (this.Path.iconURL) {
          this.constructor.iconURL = this.Path.iconURL;
        }
        if (this.Path.category) {
          this.constructor.category = this.Path.category;
        }
        if (this.Path.cursor) {
          this.constructor.cursor = this.Path.cursor;
        }
        if (justCreated && (R.tools[this.name] != null)) {
          g[this.Path.constructor.name] = this.Path;
          R.tools[this.name].remove();
          delete R.tools[this.name];
          R.lastPathCreated = this.Path;
        }
        R.tools[this.name] = this;
        this.btnJ = R.sidebar.favoriteToolsJ.find('li[data-name="' + this.name + '"]');
        PathTool.__super__.constructor.call(this, this.btnJ.length === 0);
        if (justCreated) {
          this.select();
        }
        if (R.userAuthenticated == null) {
          R.toolManager.enableDrawingButton(false);
        }
        return;
      }

      PathTool.prototype.remove = function() {
        this.btnJ.remove();
      };

      PathTool.prototype.select = function(deselectItems, updateParameters, forceSelect, selectedBy) {
        var bounds, ref, ref1;
        if (deselectItems == null) {
          deselectItems = true;
        }
        if (updateParameters == null) {
          updateParameters = true;
        }
        if (forceSelect == null) {
          forceSelect = false;
        }
        if (selectedBy == null) {
          selectedBy = 'default';
        }
        if ((ref = R.city) != null ? ref.finished : void 0) {
          R.alertManager.alert("Cette édition est terminée, vous ne pouvez plus dessiner.", 'info');
          return;
        }
        if (!R.userAuthenticated && !forceSelect) {
          R.alertManager.alert('Log in before drawing', 'info');
          return;
        }
        this.showDraftLimits();
        if ((ref1 = R.tracer) != null) {
          ref1.show();
        }
        PathTool.__super__.select.call(this, deselectItems, updateParameters, selectedBy);
        R.view.tool.onMouseMove = this.move;
        R.toolManager.enterDrawingMode();
        if (selectedBy !== 'middleMouseButton' && selectedBy !== 'spaceKey') {
          if (this.draftLimit != null) {
            if (!P.view.bounds.intersects(this.draftLimit)) {
              bounds = R.Drawing.getDraft().getBounds();
              R.view.fitRectangle(bounds, false, P.view.zoom < 1 ? 1 : P.view.zoom);
            }
          }
        }
        if (P.view.zoom < 1) {
          R.alertManager.alert('You can zoom in to draw more easily', 'info');
        }
      };

      PathTool.prototype.updateParameters = function() {};

      PathTool.prototype.deselect = function() {
        PathTool.__super__.deselect.call(this);
        this.finish();
        this.hideDraftLimits();
        R.view.tool.onMouseMove = null;
      };

      PathTool.prototype.beginBackup = function(event, from, data) {
        var bounds, intersection, ref, ref1, ref2, ref3;
        if (from == null) {
          from = R.me;
        }
        if (data == null) {
          data = null;
        }
        if (event.event.which === 2) {
          return;
        }
        if ((ref = R.tracer) != null ? ref.draggingImage : void 0) {
          return;
        }
        if (P.view.zoom < 0.5) {
          R.alertManager.alert('Please zoom before drawing', 'info');
          return;
        }
        if ((this.draftLimit != null) && !this.draftLimit.contains(event.point)) {
          this.constructor.displayDraftIsTooBigError();
          bounds = (ref1 = R.Drawing.getDraft()) != null ? ref1.getBounds() : void 0;
          if (bounds != null) {
            intersection = R.view.getViewBounds(true).intersect(bounds);
            if (intersection.width < 0 || intersection.height < 0 || intersection.area < 10000) {
              R.view.fitRectangle(bounds, false, P.view.zoom < 1 ? 1 : P.view.zoom);
            }
          }
          return;
        }
        if (!((R.currentPaths[from] != null) && ((ref2 = R.currentPaths[from].data) != null ? ref2.polygonMode : void 0))) {
          R.tools.select.deselectAll(false);
          R.currentPaths[from] = new this.Path(Date.now(), data, null, null, null, null, R.me);
          if (this.circleMode()) {
            this.circlePathRadius = 0.1;
            this.circlePathCenter = event.point;
            if (ref3 = R.drawingMode, indexOf.call(R.Path.PrecisePath.snappedModes, ref3) >= 0) {
              this.circlePathCenter = Utils.Snap.snap2D(event.point, R.drawingMode === 'lineOrthoDiag' ? R.Path.PrecisePath.lineOrthoGridSize : R.Path.PrecisePath.orthoGridSize / 2);
            }
            this.animateCircle(0, true);
            this.animateCircleIntervalID = setInterval(this.animateCircle, 150);
          }
        }
        R.currentPaths[from].beginCreate(event.point, event, false);
        if (this.constructor.emitSocket && (R.me != null) && from === R.me) {
          data = R.currentPaths[from].data;
          data.id = R.currentPaths[from].id;
        }
        this.using = true;
      };

      PathTool.prototype.begin = function(event, from, data) {
        var bounds, intersection, ref, ref1;
        if (from == null) {
          from = R.me;
        }
        if (data == null) {
          data = null;
        }
        if (event.event.which === 2) {
          return;
        }
        if ((ref = R.tracer) != null ? ref.draggingImage : void 0) {
          return;
        }
        if (P.view.zoom < 0.5) {
          R.alertManager.alert('Please zoom before drawing', 'info');
          return;
        }
        if ((this.draftLimit != null) && !this.draftLimit.contains(event.point)) {
          this.constructor.displayDraftIsTooBigError();
          bounds = (ref1 = R.Drawing.getDraft()) != null ? ref1.getBounds() : void 0;
          if (bounds != null) {
            intersection = R.view.getViewBounds(true).intersect(bounds);
            if (intersection.width < 0 || intersection.height < 0 || intersection.area < 10000) {
              R.view.fitRectangle(bounds, false, P.view.zoom < 1 ? 1 : P.view.zoom);
            }
          }
          return;
        }
        if (this.currentPath == null) {
          R.tools.select.deselectAll(false);
          this.currentPath = new P.Path();
          this.currentPath.strokeWidth = this.Path.strokeWidth;
          this.currentPath.strokeColor = R.selectedColor;
          this.currentPath.strokeCap = 'round';
          this.currentPath.strokeJoin = 'round';
          this.currentPath.shadowColor = 'lightblue';
          this.currentPath.shadowBlur = 10;
          this.currentPath.shadowOffset = new P.Point(0, 0);
          this.currentPath.add(event.point);
        }
        this.using = true;
        R.socket.emit("draw begin", R.me, event.point);
      };

      PathTool.prototype.animateCircleBackup = function(time, createCircle, from) {
        var path, ref;
        if (createCircle == null) {
          createCircle = false;
        }
        if (from == null) {
          from = R.me;
        }
        path = R.currentPaths[from];
        if ((createCircle || (this.circlePath != null)) && (path != null)) {
          if ((ref = this.circlePath) != null) {
            ref.remove();
          }
          this.circlePath = new P.Path.Circle(this.circlePathCenter, this.circlePathRadius);
          this.circlePath.strokeColor = path.data.strokeColor;
          this.circlePath.strokeWidth = path.data.strokeWidth;
          this.circlePathRadius += 4;
        } else {
          clearInterval(this.animateCircleIntervalID);
          this.animateCircleIntervalID = null;
        }
      };

      PathTool.prototype.showDraftLimits = function() {
        var child, draftBounds, i, l1, l2, l3, l4, len, path, ref, viewBounds;
        this.hideDraftLimits();
        draftBounds = this.constructor.computeDraftBounds();
        path = R.currentPaths[R.me];
        if (this.currentPath != null) {
          if (draftBounds != null) {
            draftBounds = draftBounds.unite(this.currentPath.bounds.expand(2 * this.Path.strokeWidth));
          } else {
            draftBounds = this.currentPath.bounds.expand(2 * this.Path.strokeWidth);
          }
        }
        if ((draftBounds == null) || draftBounds.area === 0) {
          return null;
        }
        viewBounds = R.view.grid.limitCD.bounds.clone();
        this.draftLimit = draftBounds.expand(2 * (this.constructor.maxDraftSize * R.city.pixelPerMm - draftBounds.width), 2 * (this.constructor.maxDraftSize * R.city.pixelPerMm - draftBounds.height));
        this.limit = new P.Group();
        l1 = new P.Path.Rectangle(viewBounds.topLeft, new P.Point(viewBounds.right, this.draftLimit.top));
        l2 = new P.Path.Rectangle(new P.Point(viewBounds.left, this.draftLimit.top), new P.Point(this.draftLimit.left, this.draftLimit.bottom));
        l3 = new P.Path.Rectangle(new P.Point(this.draftLimit.right, this.draftLimit.top), new P.Point(viewBounds.right, this.draftLimit.bottom));
        l4 = new P.Path.Rectangle(new P.Point(viewBounds.left, this.draftLimit.bottom), viewBounds.bottomRight);
        this.limit.addChild(l1);
        this.limit.addChild(l2);
        this.limit.addChild(l3);
        this.limit.addChild(l4);
        ref = this.limit.children;
        for (i = 0, len = ref.length; i < len; i++) {
          child = ref[i];
          child.fillColor = new P.Color(0, 0, 0, 0.25);
        }
        R.view.selectionLayer.addChild(this.limit);
        this.limit.sendToBack();
        return this.draftLimit;
      };

      PathTool.prototype.hideDraftLimits = function() {
        if (this.limit != null) {
          this.limit.remove();
        }
        this.draftLimit = null;
      };

      PathTool.prototype.updateBackup = function(event, from) {
        var draftIsOutsideFrame, draftIsTooBig, draftLimit, p, path;
        if (from == null) {
          from = R.me;
        }
        if (this.selectedSegment != null) {
          this.selectedSegment.point = event.point;
          R.selectedPath = this.selectedSegment.path.controller;
          return;
        }
        path = R.currentPaths[from];
        if (path == null) {
          return;
        }
        if (this.circleMode() && (this.circlePath != null)) {
          this.circlePath.remove();
          this.circlePath = null;
          clearInterval(this.animateCircleIntervalID);
        }
        draftLimit = this.showDraftLimits();
        draftIsTooBig = (draftLimit != null) && !draftLimit.contains(event.point);
        draftIsOutsideFrame = !R.view.contains(event.point);
        if (draftIsTooBig || draftIsOutsideFrame) {
          if (R.drawingMode !== 'line' && R.drawingMode !== 'lineOrthoDiag') {
            if (draftIsTooBig) {
              this.constructor.displayDraftIsTooBigError();
            } else if (draftIsOutsideFrame) {
              R.alertManager.alert('Your path must be in the drawing area', 'error');
            }
            this.end(event, from);
            if (path.path != null) {
              p = path.path.clone();
              p.strokeColor = 'red';
              R.view.mainLayer.addChild(p);
              setTimeout(((function(_this) {
                return function() {
                  return p.remove();
                };
              })(this)), 1000);
            }
            this.showDraftLimits();
          }
          return;
        }
        path.updateCreate(event.point, event, false);
      };

      PathTool.prototype.showPathError = function(event, from) {
        var p;
        if (from == null) {
          from = R.me;
        }
        p = this.currentPath.clone();
        p.strokeColor = 'red';
        R.view.mainLayer.addChild(p);
        setTimeout(((function(_this) {
          return function() {
            return p.remove();
          };
        })(this)), 1000);
        event.point = this.currentPath.lastSegment.point;
        this.end(event, from);
        this.showDraftLimits();
      };

      PathTool.prototype.update = function(event, from) {
        var draftIsOutsideFrame, draftIsTooBig, draftLimit;
        if (from == null) {
          from = R.me;
        }
        if (this.currentPath == null) {
          return;
        }
        draftLimit = this.showDraftLimits();
        draftIsTooBig = (draftLimit != null) && !draftLimit.contains(event.point);
        draftIsOutsideFrame = !R.view.contains(event.point);
        if (draftIsTooBig || draftIsOutsideFrame) {
          if (draftIsTooBig) {
            this.constructor.displayDraftIsTooBigError();
          } else if (draftIsOutsideFrame) {
            R.alertManager.alert('Your path must be in the drawing area', 'error');
          }
          this.showPathError(event, from);
          return;
        }
        this.currentPath.add(event.point);
        R.socket.emit("draw update", R.me, event.point);
      };

      PathTool.prototype.moveBackup = function(event) {
        var base, ref, ref1;
        if ((ref = R.currentPaths[R.me]) != null ? (ref1 = ref.data) != null ? ref1.polygonMode : void 0 : void 0) {
          if (typeof (base = R.currentPaths[R.me]).createMove === "function") {
            base.createMove(event);
          }
        }
      };

      PathTool.prototype.move = function(event) {};

      PathTool.prototype.end = function(event, from) {
        var draft, draftLimit;
        if (from == null) {
          from = R.me;
        }
        if (this.currentPath == null) {
          return;
        }
        this.using = false;
        this.currentPath.add(event.point);
        draftLimit = this.showDraftLimits();
        if ((this.draftLimit != null) && !this.draftLimit.contains(this.currentPath.bounds)) {
          this.constructor.displayDraftIsTooBigError();
          this.currentPath.remove();
          this.currentPath = null;
          return false;
        }
        draft = R.Item.Drawing.getDraft();
        R.commandManager.add(new Command.ModifyDrawing(draft));
        if (!(this.currentPath.segments.length === 2 && this.currentPath.firstSegment.point.equals(this.currentPath.lastSegment.point))) {
          this.currentPath.simplify();
        }
        draft.addChild(this.currentPath, true);
        this.currentPath = null;
        R.toolManager.updateButtonsVisibility();
        R.socket.emit("draw end", R.me, event.point);
      };

      PathTool.prototype.finish = function(from) {
        var ref, ref1;
        if (from == null) {
          from = R.me;
        }
        if (!((ref = R.currentPaths[R.me]) != null ? (ref1 = ref.data) != null ? ref1.polygonMode : void 0 : void 0)) {
          return false;
        }
        return true;
      };

      PathTool.prototype.keyUp = function(event) {
        var finishingPath;
        switch (event.key) {
          case 'enter':
            if (typeof this.finish === "function") {
              this.finish();
            }
            break;
          case 'escape':
            finishingPath = typeof this.finish === "function" ? this.finish() : void 0;
            if (!finishingPath) {
              R.tools.select.deselectAll();
            }
        }
      };

      return PathTool;

    })(Tool);
    R.Tools.Path = PathTool;
    return PathTool;
  });

}).call(this);
