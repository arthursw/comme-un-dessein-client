// Generated by CoffeeScript 1.10.0
(function() {
  define(['paper', 'R', 'Utils/Utils', 'i18next'], function(P, R, Utils, i18next) {
    var Camera;
    Camera = (function() {
      function Camera() {}

      Camera.threeSize = 900;

      Camera.initialized = false;

      Camera.initialize = function() {
        console.log('initialize camera');
        require(['three'], function(THREE) {
          window.THREE = THREE;
          console.log('three loaded');
          require(['EffectComposer', 'RenderPass', 'ShaderPass', 'paletteShader', 'adaptiveThresholdShader', 'separateColorsShader', 'stripesShader', 'erodeShader', 'vertexShader', 'gui'], function(EffectComposer, RenderPass, ShaderPass, paletteShader, adaptiveThresholdShader, separateColorsShader, stripesShader, erodeShader, vertexShader, GUI) {
            console.log('everything else loaded');
            Camera.initializeThreeJS(THREE, EffectComposer, RenderPass, ShaderPass, paletteShader, adaptiveThresholdShader, separateColorsShader, stripesShader, erodeShader, vertexShader, GUI);
          });
        });
      };

      Camera.initializeThreeJS = function(THREE, EffectComposer, RenderPass, ShaderPass, paletteShader, adaptiveThresholdShader, separateColorsShader, stripesShader, erodeShader, vertexShader, GUI) {
        var black, blue, brown, c, color, colorVectorArray, colors, constraints, green, i, len, minDimension, red, threeHeight, threeWidth, white, yellow;
        console.log('initializeThreeJS');
        $('#camera').show();
        $('#camera').addClass('active');
        Camera.scene = new THREE.Scene();
        Camera.camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
        Camera.stream = null;
        threeWidth = Camera.threeSize;
        threeHeight = Camera.threeSize;
        minDimension = Math.min(threeWidth, threeHeight);
        Camera.canvas = document.createElement("canvas");
        $(Camera.canvas).css({
          top: '50%',
          left: '50%',
          transform: 'translate(-50%, -50%)'
        });
        Camera.context = canvas.getContext("webgl");
        Camera.renderer = new THREE.WebGLRenderer({
          canvas: Camera.canvas,
          context: Camera.context,
          minFilter: THREE.NearestFilter,
          magFilter: THREE.NearestFilter,
          format: THREE.RGBFormat,
          stencilBuffer: true
        });
        Camera.renderer.setPixelRatio(1);
        Camera.renderer.setSize(minDimension, minDimension);
        document.body.appendChild(Camera.renderer.domElement);
        Camera.video = document.createElement('video');
        Camera.texture = new THREE.VideoTexture(Camera.video);
        red = '#F44336';
        blue = '#448AFF';
        green = '#8BC34A';
        yellow = '#FFC107';
        brown = '#704433';
        white = '#FFFFFF';
        black = '#000000';
        colors = [red, blue, green, yellow, brown, black, white];
        if (R.isCommeUnDessein || !R.useColors) {
          colors = [black, black, black, black, black, black, white];
        }
        colorVectorArray = [];
        for (i = 0, len = colors.length; i < len; i++) {
          color = colors[i];
          c = new THREE.Color(color);
          colorVectorArray.push(new THREE.Vector3(c.r, c.g, c.b));
        }
        Camera.uniforms = {
          time: {
            type: "f",
            value: Date.now()
          },
          label: {
            type: "b",
            value: false
          },
          resolution: {
            type: "v2",
            value: new THREE.Vector2(minDimension, minDimension)
          },
          tDiffuse: {
            value: Camera.texture
          },
          hue: {
            value: 0.0
          },
          saturation: {
            value: 0.0
          },
          lightness: {
            value: 0.0
          },
          C: {
            value: 0.05
          },
          windowSize: {
            value: 15
          },
          stripeWidth: {
            value: 5
          },
          mousePosition: {
            value: new THREE.Vector2(0.5, 0.5)
          },
          colors: {
            type: "v3v",
            value: colorVectorArray
          }
        };
        Camera.material = new THREE.MeshBasicMaterial({
          map: Camera.texture
        });
        Camera.geometry = new THREE.PlaneGeometry(2, 2);
        Camera.sprite = new THREE.Mesh(Camera.geometry, Camera.material);
        Camera.scene.add(Camera.sprite);
        Camera.effectComposer = new THREE.EffectComposer(Camera.renderer);
        Camera.renderPass = new THREE.RenderPass(Camera.scene, Camera.camera);
        Camera.effectComposer.addPass(Camera.renderPass);
        Camera.paletteShaderPass = new THREE.ShaderPass({
          uniforms: Camera.uniforms,
          vertexShader: vertexShader.trim(),
          fragmentShader: paletteShader.trim()
        });
        Camera.effectComposer.addPass(Camera.paletteShaderPass);
        console.log('create @paletteShaderPass:', Camera.paletteShaderPass);
        Camera.paletteShaderPass.enabled = false;
        Camera.separateColorsShaderPass = new THREE.ShaderPass({
          uniforms: Camera.uniforms,
          vertexShader: vertexShader.trim(),
          fragmentShader: separateColorsShader.trim()
        });
        Camera.effectComposer.addPass(Camera.separateColorsShaderPass);
        Camera.separateColorsShaderPass.enabled = false;
        Camera.erodeShaderPass = new THREE.ShaderPass({
          uniforms: Camera.uniforms,
          vertexShader: vertexShader.trim(),
          fragmentShader: erodeShader.trim()
        });
        Camera.effectComposer.addPass(Camera.erodeShaderPass);
        Camera.effectComposer.addPass(Camera.erodeShaderPass);
        Camera.effectComposer.addPass(Camera.erodeShaderPass);
        Camera.erodeShaderPass.enabled = false;
        Camera.stripesShaderPass = new THREE.ShaderPass({
          uniforms: Camera.uniforms,
          vertexShader: vertexShader.trim(),
          fragmentShader: stripesShader.trim()
        });
        Camera.effectComposer.addPass(Camera.stripesShaderPass);
        Camera.stripesShaderPass.enabled = false;
        Camera.adaptiveThresholdShaderPass = new THREE.ShaderPass({
          uniforms: Camera.uniforms,
          vertexShader: vertexShader.trim(),
          fragmentShader: adaptiveThresholdShader.trim()
        });
        Camera.effectComposer.addPass(Camera.adaptiveThresholdShaderPass);
        Camera.adaptiveThresholdShaderPass.enabled = false;
        window.addEventListener("resize", Camera.onWindowResize, false);
        $('#camera').prepend(Camera.canvas);
        Camera.animate();
        if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
          constraints = {
            video: {
              facingMode: 'environment'
            }
          };
          navigator.mediaDevices.getUserMedia(constraints).then(function(stream) {
            Camera.stream = stream;
            Camera.video.srcObject = stream;
            return Camera.video.play();
          })["catch"](function(error) {
            return console.error('Unable to access the camera/webcam.', error);
          });
        } else {
          console.error('MediaDevices interface not available.');
        }
        if (!Camera.initialized) {
          $('#cancel-photo').click(Camera.cancelPhoto);
          $('#take-photo').click(Camera.takePhoto);
          if (Camera.sliders == null) {
            Camera.sliders = {};
          }
          Camera.initializeSliders('saturation');
          Camera.initializeSliders('lightness');
          Camera.initialized = true;
          $('#camera').mousemove(function(event) {
            event.preventDefault();
            event.stopPropagation();
            return -1;
          });
        }
      };

      Camera.initializeSliders = function(name) {
        var sliderJ;
        sliderJ = $('.cd-slider.' + name);
        sliderJ.find('.btn.minus').click(function() {
          return Camera.addParameter(name, -5);
        });
        sliderJ.find('.btn.plus').click(function() {
          return Camera.addParameter(name, 5);
        });
        sliderJ.find('.cd-inline').click(function(event) {
          return Camera.setParameter(name, event);
        });
        Camera.sliders[name] = {
          dragging: false
        };
        sliderJ.find('.cd-inline').mousedown(function() {
          return Camera.sliders[name].dragging = true;
        });
        sliderJ.find('.cd-inline').mousemove(function(event) {
          if (Camera.sliders[name].dragging) {
            Camera.setParameter(name, event);
            event.preventDefault();
            event.stopPropagation();
          }
          return -1;
        });
        $(window).mouseup(function() {
          return Camera.sliders[name].dragging = false;
        });
      };

      Camera.updateSlider = function(name, value) {
        var iconJ, line1J, line2J, percent;
        iconJ = $('.cd-slider.' + name + ' .cd-inline .glyphicon');
        percent = Math.round((1 + value) * 0.5 * 100);
        iconJ.css({
          left: percent + '%'
        });
        line1J = $('.cd-slider.' + name + ' .cd-inline .cd-line:first-child');
        line1J.css({
          width: 'calc(' + percent + '% - 20px)'
        });
        line2J = $('.cd-slider.' + name + ' .cd-inline .cd-line:last-child');
        line2J.css({
          width: 'calc(' + (100 - percent) + '% - 20px)',
          left: percent + '%'
        });
      };

      Camera.addParameter = function(name, delta) {
        var value;
        value = Camera.paletteShaderPass.uniforms[name].value + (delta / 100) * 2;
        if (value < -1) {
          value = -1;
        }
        if (value > 1) {
          value = 1;
        }
        Camera.paletteShaderPass.uniforms[name].value = value;
        Camera.updateSlider(name, value);
      };

      Camera.setParameter = function(name, event) {
        var lineJ, value;
        lineJ = $('.cd-slider.' + name + ' .cd-inline');
        value = (event.clientX - lineJ.offset().left) / lineJ.width();
        value = -1 + 2 * value;
        Camera.paletteShaderPass.uniforms[name].value = value;
        Camera.updateSlider(name, value);
      };

      Camera.cancelPhoto = function() {
        Camera.remove();
      };

      Camera.takePhoto = function() {
        Camera.paletteShaderPass.enabled = true;
        Camera.separateColorsShaderPass.enabled = true;
        Camera.erodeShaderPass.enabled = true;
        Camera.stripesShaderPass.enabled = true;
        Camera.effectComposer.render();
        R.tracer.imageURL = Camera.renderer.domElement.toDataURL();
        Camera.paletteShaderPass.enabled = true;
        Camera.separateColorsShaderPass.enabled = false;
        Camera.erodeShaderPass.enabled = false;
        Camera.stripesShaderPass.enabled = false;
        Camera.remove();
        R.tracer.setEditImageMode();
      };

      Camera.resizePlane = function() {
        var newPlaneGeometry, ts;
        if (Camera.texture.image && Camera.texture.image.naturalWidth > 0 && Camera.texture.image.naturalHeight > 0) {
          ts = Camera.threeSize;
          newPlaneGeometry = new THREE.PlaneGeometry(texture.image.naturalWidth / ts, texture.image.naturalHeight / ts);
          geometry.vertices = newPlaneGeometry.vertices;
          geometry.verticesNeedUpdate = true;
        }
      };

      Camera.onWindowResize = function() {
        var minDimension, threeHeight, threeWidth;
        threeWidth = Camera.threeSize;
        threeHeight = Camera.threeSize;
        minDimension = Math.min(threeWidth, threeHeight);
        Camera.renderer.setSize(minDimension, minDimension);
        Camera.effectComposer.setSize(minDimension, minDimension);
        Camera.resizePlane();
      };

      Camera.animate = function(timestamp) {
        if (timestamp == null) {
          timestamp = 0;
        }
        if (Camera.renderer != null) {
          requestAnimationFrame(Camera.animate);
          Camera.effectComposer.render();
        }
      };

      Camera.remove = function() {
        if (Camera.stream != null) {
          Camera.stream.getTracks().forEach(function(track) {
            return track.stop();
          });
        }
        window.removeEventListener("resize", Camera.onWindowResize, false);
        $('#camera').hide();
        $(Camera.renderer.domElement).remove();
        $(Camera.canvas).remove();
        $(Camera.video).remove();
        Camera.renderer = null;
        Camera.scene = null;
        Camera.canvas = null;
        Camera.context = null;
        Camera.sprite = null;
        Camera.material = null;
        Camera.geometry = null;
        Camera.effectComposer = null;
        Camera.renderPass = null;
        Camera.paletteShaderPass = null;
      };

      return Camera;

    })();
    ({
      constructor: function() {}
    });
    return Camera;
  });

}).call(this);
