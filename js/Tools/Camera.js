// Generated by CoffeeScript 1.10.0
(function() {
  define(['paper', 'R', 'Utils/Utils', 'i18next'], function(P, R, Utils, i18next) {
    var Camera;
    Camera = (function() {
      function Camera() {}

      Camera.initialize = function() {
        console.log('initialize camera');
        require(['three'], function(THREE) {
          window.THREE = THREE;
          console.log('three loaded');
          require(['EffectComposer', 'RenderPass', 'ShaderPass', 'grayscaleShader', 'adaptiveThresholdShader', 'vertexShader', 'gui'], function(EffectComposer, RenderPass, ShaderPass, grayscaleShader, adaptiveThresholdShader, vertexShader, GUI) {
            console.log('everything else loaded');
            Camera.initializeThreeJS(THREE, EffectComposer, RenderPass, ShaderPass, grayscaleShader, adaptiveThresholdShader, vertexShader, GUI);
          });
        });
      };

      Camera.initializeThreeJS = function(THREE, EffectComposer, RenderPass, ShaderPass, grayscaleShader, adaptiveThresholdShader, vertexShader, GUI) {
        var constraints, threeHeight, threeWidth;
        console.log('initializeThreeJS');
        $('#camera').addClass('active');
        Camera.scene = new THREE.Scene();
        Camera.camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
        threeWidth = window.innerWidth;
        threeHeight = window.innerHeight;
        Camera.canvas = document.createElement("canvas");
        Camera.context = canvas.getContext("webgl");
        Camera.renderer = new THREE.WebGLRenderer({
          canvas: Camera.canvas,
          context: Camera.context,
          minFilter: THREE.NearestFilter,
          magFilter: THREE.NearestFilter,
          format: THREE.RGBFormat,
          stencilBuffer: true
        });
        Camera.renderer.setPixelRatio(window.devicePixelRatio);
        Camera.renderer.setSize(threeWidth, threeHeight);
        document.body.appendChild(Camera.renderer.domElement);
        Camera.video = document.createElement('video');
        Camera.texture = new THREE.VideoTexture(Camera.video);
        Camera.uniforms = {
          time: {
            type: "f",
            value: Date.now()
          },
          resolution: {
            type: "v2",
            value: new THREE.Vector2(threeWidth, threeHeight)
          },
          tDiffuse: {
            value: Camera.texture
          },
          threshold1: {
            value: 0.3
          },
          threshold2: {
            value: 0.3
          },
          C: {
            value: 0.05
          },
          windowSize: {
            value: 15
          },
          mousePosition: {
            value: new THREE.Vector2(0.5, 0.5)
          }
        };
        Camera.material = new THREE.MeshBasicMaterial({
          map: Camera.texture
        });
        Camera.geometry = new THREE.PlaneGeometry(2, 2);
        Camera.sprite = new THREE.Mesh(Camera.geometry, Camera.material);
        Camera.scene.add(Camera.sprite);
        Camera.effectComposer = new THREE.EffectComposer(Camera.renderer);
        Camera.renderPass = new THREE.RenderPass(Camera.scene, Camera.camera);
        Camera.effectComposer.addPass(Camera.renderPass);
        Camera.grayscaleShaderPass = new THREE.ShaderPass({
          uniforms: Camera.uniforms,
          vertexShader: vertexShader.trim(),
          fragmentShader: grayscaleShader.trim()
        });
        Camera.effectComposer.addPass(Camera.grayscaleShaderPass);
        window.addEventListener("resize", Camera.onWindowResize, false);
        $('#camera').append(Camera.canvas);
        Camera.animate();
        if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
          constraints = {
            video: {
              width: 400,
              height: 400,
              facingMode: 'user'
            }
          };
          navigator.mediaDevices.getUserMedia(constraints).then(function(stream) {
            Camera.video.srcObject = stream;
            return Camera.video.play();
          })["catch"](function(error) {
            return console.error('Unable to access the camera/webcam.', error);
          });
        } else {
          console.error('MediaDevices interface not available.');
        }
        Camera.gui = new dat.GUI({
          autoPlace: false
        });
        Camera.gui.add(Camera.grayscaleShaderPass.uniforms.threshold1, 'value', 0, 1, 0.01).name('Threshold 1');
        Camera.gui.add(Camera.grayscaleShaderPass.uniforms.threshold2, 'value', 0, 1, 0.01).name('Threshold 1');
        $('#camera').append(Camera.gui.domElement);
        $(Camera.gui.domElement).css({
          'z-index': 10002,
          position: 'absolute',
          right: 0,
          bottom: 0
        });
        $('#cancel-photo').click(Camera.cancelPhoto);
        $('#take-photo').click(Camera.cancelPhoto);
      };

      Camera.cancelPhoto = function() {
        Camera.remove();
      };

      Camera.takePhoto = function() {
        Camera.renderer.domElement.toBlob(function(blob) {
          var image, reader;
          image = new Image();
          reader = new FileReader();
          reader.onload = function(e) {
            image.src = e.target.result;
            image.onload = function() {
              var context, height, imageCanvas, imageData, width;
              imageCanvas = document.createElement("canvas");
              width = Math.floor(image.width);
              height = Math.floor(image.height);
              imageCanvas.width = width;
              imageCanvas.height = height;
              context = imageCanvas.getContext('2d');
              context.drawImage(image, 0, 0, width, height);
              imageData = context.getImageData(0, 0, width, height).data;
              traceHomeMadeProcess(imageData, width, height);
            };
          };
        });
        reader.readAsDataURL(blob);
        Camera.remove();
      };

      Camera.resizePlane = function() {
        var newPlaneGeometry;
        if (Camera.texture.image && Camera.texture.image.naturalWidth > 0 && Camera.texture.image.naturalHeight > 0) {
          newPlaneGeometry = new THREE.PlaneGeometry(texture.image.naturalWidth / window.innerWidth, texture.image.naturalHeight / window.innerHeight);
          geometry.vertices = newPlaneGeometry.vertices;
          geometry.verticesNeedUpdate = true;
        }
      };

      Camera.onWindowResize = function() {
        var threeHeight, threeWidth;
        threeWidth = window.innerWidth;
        threeHeight = window.innerHeight;
        Camera.renderer.setSize(threeWidth, threeHeight);
        Camera.effectComposer.setSize(threeWidth, threeHeight);
        Camera.resizePlane();
      };

      Camera.animate = function(timestamp) {
        if (timestamp == null) {
          timestamp = 0;
        }
        if (Camera.renderer != null) {
          requestAnimationFrame(Camera.animate);
          Camera.effectComposer.render();
        }
      };

      Camera.remove = function() {
        $('#camera').hide();
        $(Camera.renderer.domElement).remove();
        $(Camera.gui.domElement).remove();
        $(Camera.canvas).remove();
        $(Camera.video).remove();
        Camera.renderer = null;
        Camera.scene = null;
        Camera.canvas = null;
        Camera.context = null;
        Camera.sprite = null;
        Camera.material = null;
        Camera.geometry = null;
        Camera.effectComposer = null;
        Camera.renderPass = null;
        Camera.grayscaleShaderPass = null;
      };

      return Camera;

    })();
    ({
      constructor: function() {}
    });
    return Camera;
  });

}).call(this);
