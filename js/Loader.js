// Generated by CoffeeScript 1.10.0
(function() {
  var bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    hasProp = {}.hasOwnProperty,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  define(['Commands/Command', 'Items/Item', 'UI/ModuleLoader', 'spin', 'Items/Lock', 'Items/Divs/Div', 'Items/Divs/Media', 'Items/Drawing', 'Items/Divs/Text'], function(Command, Item, ModuleLoader, Spinner) {
    var Loader, RasterizerLoader;
    Loader = (function() {
      function Loader() {
        this.checkError = bind(this.checkError, this);
        this.loadCallback = bind(this.loadCallback, this);
        this.hideLoadingBar = bind(this.hideLoadingBar, this);
        this.showLoadingBar = bind(this.showLoadingBar, this);
        this.showLoadingBarCallback = bind(this.showLoadingBarCallback, this);
        this.loadedAreas = [];
        this.debug = false;
        this.pathsToCreate = {};
        this.initializeLoadingBar();
        this.showLoadingBar();
        return;
      }

      Loader.prototype.initializeLoadingBar = function() {
        var opts, target;
        opts = {
          lines: 17,
          length: 13,
          width: 8,
          radius: 0,
          scale: 1.5,
          corners: 0,
          color: '#ccc',
          opacity: 0.15,
          rotate: 0,
          direction: 1,
          speed: 1,
          trail: 38,
          fps: 20,
          zIndex: 2e9,
          className: 'spinner',
          top: '50%',
          left: '130px',
          shadow: false,
          hwaccel: false,
          position: 'relative'
        };
        target = document.getElementById('spinner');
      };

      Loader.prototype.showDrawingBar = function() {
        $("#drawingBar").show();
      };

      Loader.prototype.hideDrawingBar = function() {
        $("#drawingBar").hide();
      };

      Loader.prototype.showLoadingBarCallback = function() {
        $("#loadingBar").show();
      };

      Loader.prototype.showLoadingBar = function(timeout) {
        if ((timeout != null) && timeout > 0) {
          this.showLoadingBarTimeoutID = setTimeout(this.showLoadingBarCallback, timeout);
        } else {
          this.showLoadingBarCallback();
        }
      };

      Loader.prototype.hideLoadingBar = function() {
        clearTimeout(this.showLoadingBarTimeoutID);
        $("#loadingBar").hide();
      };

      Loader.prototype.areaIsLoaded = function(pos, planet, qZoom) {
        var area, k, len, ref;
        ref = this.loadedAreas;
        for (k = 0, len = ref.length; k < len; k++) {
          area = ref[k];
          if (area.planet.x === planet.x && area.planet.y === planet.y) {
            if (area.pos.x === pos.x && area.pos.y === pos.y) {
              if ((qZoom == null) || area.zoom === qZoom) {
                return true;
              }
            }
          }
        }
        return false;
      };

      Loader.prototype.unload = function() {
        var id, item, ref;
        this.loadedAreas = [];
        ref = R.items;
        for (id in ref) {
          if (!hasProp.call(ref, id)) continue;
          item = ref[id];
          item.remove();
        }
        R.items = {};
        R.rasterizer.clearRasters();
        this.previousLoadPosition = null;
      };

      Loader.prototype.loadRequired = function() {
        if (this.previousLoadPosition != null) {
          if (this.previousLoadPosition.position.subtract(P.view.center).length < 50) {
            if (Math.abs(1 - this.previousLoadPosition.zoom / P.view.zoom) < 0.2) {
              return false;
            }
          }
        }
        return true;
      };

      Loader.prototype.getLoadingBounds = function(area) {
        var halfSize;
        if (area == null) {
          if (P.view.bounds.width <= window.innerWidth && P.view.bounds.height <= window.innerHeight) {
            return P.view.bounds;
          } else {
            halfSize = new P.Point(window.innerWidth * 0.5, window.innerHeight * 0.5);
            return new P.Rectangle(P.view.center.subtract(halfSize), P.view.center.add(halfSize));
          }
        }
        return area;
      };

      Loader.prototype.unloadAreas = function(area, limit, qZoom) {
        var i, id, item, itemsOutsideLimit, j, pos, rectangle, ref;
        itemsOutsideLimit = [];
        ref = R.items;
        for (id in ref) {
          if (!hasProp.call(ref, id)) continue;
          item = ref[id];
          if (!item.getBounds().intersects(limit)) {
            itemsOutsideLimit.push(item);
          }
        }
        i = this.loadedAreas.length;
        while (i--) {
          area = this.loadedAreas[i];
          pos = Utils.CS.posOnPlanetToProject(area.pos, area.planet);
          rectangle = new P.Rectangle(pos.x, pos.y, R.scale * area.zoom, R.scale * area.zoom);
          if (!rectangle.intersects(limit) || area.zoom !== qZoom) {
            if (this.debug) {
              this.updateDebugArea(area);
            }
            this.loadedAreas.splice(i, 1);
            j = itemsOutsideLimit.length;
            while (j--) {
              item = itemsOutsideLimit[j];
              if (item.getBounds().intersects(rectangle)) {
                item.remove();
                itemsOutsideLimit.splice(j, 1);
              }
            }
          }
        }
      };

      Loader.prototype.getAreaToLoad = function(areasToLoad, pos, planet, x, y, scale, qZoom) {
        var area;
        if (!this.areaIsLoaded(pos, planet, qZoom)) {
          area = {
            pos: pos,
            planet: planet
          };
          areasToLoad.push(area);
          area.zoom = qZoom;
          if (this.debug) {
            this.createAreaDebugRectangle(x, y, scale);
          }
          this.loadedAreas.push(area);
        }
      };

      Loader.prototype.getAreasToLoad = function(scale, qZoom, t, l, b, r) {
        var areasToLoad, k, m, planet, pos, ref, ref1, ref2, ref3, ref4, ref5, x, y;
        areasToLoad = [];
        for (x = k = ref = l, ref1 = r, ref2 = scale; ref2 > 0 ? k <= ref1 : k >= ref1; x = k += ref2) {
          for (y = m = ref3 = t, ref4 = b, ref5 = scale; ref5 > 0 ? m <= ref4 : m >= ref4; y = m += ref5) {
            planet = Utils.CS.projectToPlanet(new P.Point(x, y));
            pos = Utils.CS.projectToPosOnPlanet(new P.Point(x, y));
            this.getAreaToLoad(areasToLoad, pos, planet, x, y, scale, qZoom);
          }
        }
        return areasToLoad;
      };

      Loader.prototype.nothingToLoad = function(areasToLoad) {
        return areasToLoad.length <= 0;
      };

      Loader.prototype.requestAreas = function(rectangle, areasToLoad, qZoom) {
        $.ajax({
          method: "POST",
          url: "ajaxCall/",
          data: {
            data: JSON.stringify({
              "function": 'load',
              args: {
                rectangle: rectangle,
                areasToLoad: areasToLoad,
                qZoom: qZoom,
                city: R.city
              }
            })
          }
        }).done(this.loadCallback);
      };

      Loader.prototype.load = function(area) {
        var areasToLoad, b, bounds, l, limit, qZoom, r, rectangle, scale, t, unloadDist;
        if (area == null) {
          area = null;
        }
        if (!this.loadRequired()) {
          return false;
        }
        console.log("load");
        if (area != null) {
          console.log(area.toString());
        }
        this.previousLoadPosition = {
          position: P.view.center,
          zoom: P.view.zoom
        };
        bounds = this.getLoadingBounds(area);
        unloadDist = Math.round(R.scale / P.view.zoom);
        limit = R.view.entireArea || bounds.expand(unloadDist);
        R.rasterizer.unload(limit);
        qZoom = Utils.CS.quantizeZoom(1.0 / P.view.zoom);
        this.unloadAreas(area, limit, qZoom);
        scale = R.scale * qZoom;
        t = Utils.floorToMultiple(bounds.top, scale);
        l = Utils.floorToMultiple(bounds.left, scale);
        b = Utils.floorToMultiple(bounds.bottom, scale);
        r = Utils.floorToMultiple(bounds.right, scale);
        if (this.debug) {
          this.updateDebugPaths(limit, bounds, t, l, b, r);
        }
        areasToLoad = this.getAreasToLoad(scale, qZoom, t, l, b, r);
        if (this.nothingToLoad(areasToLoad)) {
          return false;
        }
        this.showDrawingBar();
        this.showLoadingBar(1000);
        rectangle = {
          left: l / 1000.0,
          top: t / 1000.0,
          right: r / 1000.0,
          bottom: b / 1000.0
        };
        this.requestAreas(rectangle, areasToLoad, qZoom);
        return true;
      };

      Loader.prototype.dispatchLoadFinished = function() {
        var commandEvent;
        console.log("dispatch command executed");
        commandEvent = document.createEvent('Event');
        commandEvent.initEvent('command executed', true, true);
        document.dispatchEvent(commandEvent);
      };

      Loader.prototype.setMe = function(user) {
        if ((R.me == null) && (user != null)) {
          R.me = user;
          if ((R.socket.chatJ != null) && R.socket.chatJ.find("#chatUserNameInput").length === 0) {
            R.socket.startChatting(R.me);
          }
        }
      };

      Loader.prototype.removeDeletedItems = function(deletedItems) {
        var deletedItemLastUpdate, id, ref;
        if (deletedItems == null) {
          return;
        }
        for (id in deletedItems) {
          deletedItemLastUpdate = deletedItems[id];
          if ((ref = R.items[id]) != null) {
            ref.remove();
          }
        }
      };

      Loader.prototype.mustLoadItem = function(item) {
        return R.items[item._id.$oid] == null;
      };

      Loader.prototype.unloadItem = function(item) {};

      Loader.prototype.parseNewItems = function(items) {
        var i, item, itemsToLoad, k, len;
        itemsToLoad = [];
        for (k = 0, len = items.length; k < len; k++) {
          i = items[k];
          item = JSON.parse(i);
          if (!this.mustLoadItem(item)) {
            continue;
          }
          this.unloadItem(item);
          if (item.rType === 'Box') {
            itemsToLoad.unshift(item);
          } else {
            itemsToLoad.push(item);
          }
        }
        return itemsToLoad;
      };

      Loader.prototype.moduleLoaded = function(args) {
        var base;
        this.createPath(args);
        delete this.pathsToCreate[args.id];
        if (Utils.isEmpty(this.pathsToCreate)) {
          this.hideDrawingBar();
          this.hideLoadingBar();
          if (typeof (base = R.rasterizer).checkRasterizeAreasToUpdate === "function") {
            base.checkRasterizeAreasToUpdate(true);
          }
        }
      };

      Loader.prototype.loadModuleAndCreatePath = function(args) {
        this.pathsToCreate[args.id] = true;
        ModuleLoader.load(args.path.object_type, (function(_this) {
          return function() {
            return _this.moduleLoaded(args);
          };
        })(this));
      };

      Loader.prototype.createPath = function(args) {
        var path, ref, ref1;
        path = new R.tools[args.path.object_type].Path(args.date, args.data, args.id, args.pk, args.points, args.lock, args.owner, (ref = args.drawing) != null ? ref.clientID : void 0);
        path.lastUpdateDate = (ref1 = args.path.lastUpdate) != null ? ref1.$date : void 0;
      };

      Loader.prototype.createNewItems = function(itemsToLoad) {
        var args, box, data, date, div, drawing, id, item, k, len, len1, lock, m, path, pk, planet, point, points, rdiv, ref, ref1, ref2, ref3, ref4, ref5, rpath;
        for (k = 0, len = itemsToLoad.length; k < len; k++) {
          item = itemsToLoad[k];
          pk = item._id.$oid;
          id = item.clientID;
          date = (ref = item.date) != null ? ref.$date : void 0;
          data = (item.data != null) && item.data.length > 0 ? JSON.parse(item.data) : null;
          lock = item.lock != null ? R.items[item.lock] : null;
          switch (item.rType) {
            case 'Box':
              box = item;
              if (box.box.coordinates[0].length < 5) {
                console.log("Error: box has less than 5 points");
              }
              lock = null;
              switch (box.object_type) {
                case 'lock':
                  lock = new Item.Lock(Utils.CS.rectangleFromBox(box), data, id, box._id.$oid, box.owner, date, (ref1 = box.module) != null ? ref1.$oid : void 0);
                  break;
                case 'link':
                  lock = new Item.Link(Utils.CS.rectangleFromBox(box), data, id, box._id.$oid, box.owner, date, (ref2 = box.module) != null ? ref2.$oid : void 0);
                  break;
                case 'website':
                  lock = new Item.Website(Utils.CS.rectangleFromBox(box), data, id, box._id.$oid, box.owner, date, (ref3 = box.module) != null ? ref3.$oid : void 0);
                  break;
                case 'video-game':
                  lock = new Item.VideoGame(Utils.CS.rectangleFromBox(box), data, id, box._id.$oid, box.owner, date, (ref4 = box.module) != null ? ref4.$oid : void 0);
              }
              lock.lastUpdateDate = box.lastUpdate.$date;
              break;
            case 'Div':
              div = item;
              if (div.box.coordinates[0].length < 5) {
                console.log("Error: box has less than 5 points");
              }
              switch (div.object_type) {
                case 'text':
                  rdiv = new Item.Text(Utils.CS.rectangleFromBox(div), data, id, pk, date, lock);
                  break;
                case 'media':
                  rdiv = new Item.Media(Utils.CS.rectangleFromBox(div), data, id, pk, date, lock);
              }
              rdiv.lastUpdateDate = div.lastUpdate.$date;
              break;
            case 'Path':
              path = item;
              if (path.owner == null) {
                console.error('A path does not have any owner!');
                continue;
              }
              planet = new P.Point(path.planetX, path.planetY);
              if (data != null) {
                data.planet = planet;
              }
              points = [];
              ref5 = path.points.coordinates;
              for (m = 0, len1 = ref5.length; m < len1; m++) {
                point = ref5[m];
                points.push(Utils.CS.posOnPlanetToProject(point, planet));
              }
              rpath = null;
              args = {
                path: path,
                date: date,
                data: data,
                id: id,
                pk: pk,
                points: points,
                lock: lock,
                owner: path.owner,
                drawing: path.drawing
              };
              if (R.tools[path.object_type] != null) {
                this.createPath(args);
              } else {
                this.loadModuleAndCreatePath(args);
              }
              break;
            case 'AreaToUpdate':
              R.rasterizer.addAreaToUpdate(Utils.CS.rectangleFromBox(item).expand(5));
              break;
            case 'Drawing':
              if (item.box.coordinates[0].length < 5) {
                console.log("Error: drawing has less than 5 points");
              }
              drawing = new Item.Drawing(Utils.CS.rectangleFromBox(item), data, id, item._id.$oid, item.owner, date, item.title, item.description, item.status);
              break;
            default:
              continue;
          }
        }
      };

      Loader.prototype.endLoading = function() {
        if (Utils.isEmpty(this.pathsToCreate)) {
          this.hideLoadingBar();
          this.hideDrawingBar();
        }
        this.dispatchLoadFinished();
      };

      Loader.prototype.loadCallback = function(results) {
        var itemsToLoad;
        console.log("load callback");
        console.log(P.project.activeLayer.name);
        if (!this.checkError(results)) {
          return;
        }
        if (results.hasOwnProperty('message') && results.message === 'no_paths') {
          this.dispatchLoadFinished();
          return;
        }
        this.setMe(results.user);
        if (results.rasters != null) {
          R.rasterizer.load(results.rasters, results.qZoom);
        }
        this.removeDeletedItems(results.deletedItems);
        itemsToLoad = this.parseNewItems(results.items);
        this.createNewItems(itemsToLoad);
        R.rasterizer.setQZoomToUpdate(results.qZoom);
        if ((results.rasters == null) || results.rasters.length === 0) {
          R.rasterizer.checkRasterizeAreasToUpdate();
        }
        Item.Div.updateZindex(R.sortedDivs);
        this.endLoading();
      };

      Loader.prototype.checkError = function(result) {
        if (result == null) {
          return true;
        }
        if (result.state === 'not_logged_in') {
          R.alertManager.alert("You must be logged in to update drawings to the database.", "info");
          this.hideLoadingBar();
          return false;
        }
        if (result.state === 'error') {
          if (result.message === 'invalid_url') {
            R.alertManager.alert("Your URL is invalid or does not point to an existing page.", "error");
          } else {
            R.alertManager.alert("Error: " + result.message, "error");
          }
          this.hideLoadingBar();
          return false;
        } else if (result.state === 'system_error') {
          console.log(result.message);
          this.hideLoadingBar();
          return false;
        }
        return true;
      };


      /* Debug methods */

      Loader.prototype.updateDebugPaths = function(limit, bounds, t, l, b, r) {
        var ref, ref1, ref2;
        if ((ref = this.unloadRectangle) != null) {
          ref.remove();
        }
        this.unloadRectangle = new P.Path.Rectangle(limit);
        this.unloadRectangle.name = '@debug load unload rectangle';
        this.unloadRectangle.strokeWidth = 1;
        this.unloadRectangle.strokeColor = 'red';
        this.unloadRectangle.dashArray = [10, 4];
        R.view.debugLayer.addChild(this.unloadRectangle);
        if ((ref1 = this.viewRectangle) != null) {
          ref1.remove();
        }
        this.viewRectangle = new P.Path.Rectangle(bounds);
        this.viewRectangle.name = '@debug load view rectangle';
        this.viewRectangle.strokeWidth = 1;
        this.viewRectangle.strokeColor = 'blue';
        R.view.debugLayer.addChild(this.viewRectangle);
        if ((ref2 = this.limitRectangle) != null) {
          ref2.remove();
        }
        this.limitRectangle = new P.Path.Rectangle(new P.Point(l, t), new P.Point(r, b));
        this.limitRectangle.name = '@debug load limit rectangle';
        this.limitRectangle.strokeWidth = 2;
        this.limitRectangle.strokeColor = 'blue';
        this.limitRectangle.dashArray = [10, 4];
        R.view.debugLayer.addChild(this.limitRectangle);
      };

      Loader.prototype.updateDebugArea = function(area) {
        area.rectangle.strokeColor = 'red';
        this.removeDebugRectangle(area.rectangle);
      };

      Loader.prototype.removeDebugRectangle = function(rectangle) {
        var removeRect;
        removeRect = function() {
          return rectangle.remove();
        };
        setTimeout(removeRect, 1500);
      };

      Loader.prototype.createAreaDebugRectangle = function(x, y, scale) {
        var areaRectangle;
        areaRectangle = new P.Path.Rectangle(x, y, scale, scale);
        areaRectangle.name = '@debug load area rectangle';
        areaRectangle.strokeWidth = 1;
        areaRectangle.strokeColor = 'green';
        R.view.debugLayer.addChild(areaRectangle);
        area.rectangle = areaRectangle;
      };

      return Loader;

    })();
    RasterizerLoader = (function(superClass) {
      extend(RasterizerLoader, superClass);

      function RasterizerLoader() {
        return RasterizerLoader.__super__.constructor.apply(this, arguments);
      }

      RasterizerLoader.prototype.loadRequired = function() {
        return true;
      };

      RasterizerLoader.prototype.nothingToLoad = function(areasToLoad) {
        return false;
      };

      RasterizerLoader.prototype.getAreaToLoad = function(areasToLoad, pos, planet, x, y, scale, qZoom) {
        var area;
        area = {
          pos: pos,
          planet: planet
        };
        areasToLoad.push(area);
        if (this.debug) {
          this.createAreaDebugRectangle(x, y, scale);
        }
        if (!this.areaIsLoaded(pos, planet)) {
          this.loadedAreas.push(area);
        }
      };

      RasterizerLoader.prototype.createItemsDates = function() {
        var id, item, itemsDates, ref;
        itemsDates = {};
        ref = R.items;
        for (id in ref) {
          item = ref[id];
          itemsDates[id] = item.lastUpdateDate;
        }
        return itemsDates;
      };

      RasterizerLoader.prototype.requestAreas = function(rectangle, areasToLoad, qZoom) {
        var itemsDates;
        itemsDates = this.createItemsDates();
        $.ajax({
          method: "POST",
          url: "ajaxCall/",
          data: {
            data: JSON.stringify({
              "function": 'loadRasterizer',
              args: {
                areasToLoad: areasToLoad,
                itemsDates: itemsDates,
                city: R.city
              }
            })
          }
        }).done(this.loadCallback);
      };

      RasterizerLoader.prototype.mustLoadItem = function() {
        return true;
      };

      RasterizerLoader.prototype.unloadItem = function(item) {
        var itemToReplace;
        itemToReplace = R.items[item._id.$oid];
        if (itemToReplace != null) {
          console.log("itemToReplace: " + itemToReplace.id);
          itemToReplace.remove();
        }
      };

      RasterizerLoader.prototype.endLoading = function() {
        if (typeof window.saveOnServer === "function") {
          R.rasterizerBot.rasterizeAndSaveOnServer();
        }
      };

      return RasterizerLoader;

    })(Loader);
    Loader.RasterizerLoader = RasterizerLoader;
    return Loader;
  });

}).call(this);
