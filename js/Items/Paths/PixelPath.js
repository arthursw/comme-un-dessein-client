// Generated by CoffeeScript 1.10.0
(function() {
  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  define(['paper', 'R', 'Utils/Utils', 'Items/Item', 'Items/Paths/Path', 'Commands/Command'], function(P, R, Utils, Item, Path, Command) {
    var PixelPath;
    PixelPath = (function(superClass) {
      extend(PixelPath, superClass);

      PixelPath.label = 'Pixel path';

      PixelPath.description = "This draws a pattern at each pixel of the path.";

      PixelPath.iconURL = 'glyphicon-pencil';

      PixelPath.orthoGridSize = 10;

      PixelPath.initializeParameters = function() {
        var parameters;
        parameters = PixelPath.__super__.constructor.initializeParameters.call(this);
        return parameters;
      };

      PixelPath.parameters = PixelPath.initializeParameters();

      PixelPath.createTool(PixelPath);

      PixelPath.getPointsFromPath = function(path) {
        var j, len, points, ref, segment;
        points = [];
        ref = path.segments;
        for (j = 0, len = ref.length; j < len; j++) {
          segment = ref[j];
          points.push(Utils.CS.projectToPosOnPlanet(segment.point));
        }
        return points;
      };

      PixelPath.getPointsAndPlanetFromPath = function(path) {
        return {
          planet: this.getPlanetFromPath(path),
          points: this.getPointsFromPath(path)
        };
      };

      PixelPath.getDataFromPath = function(path) {
        var data;
        data = {};
        data.planet = this.getPlanetFromPath(path);
        data.points = this.getPointsFromPath(path);
        return data;
      };

      function PixelPath(date, data1, id, pk, points, lock, owner, drawingId) {
        this.date = date != null ? date : null;
        this.data = data1 != null ? data1 : null;
        this.id = id != null ? id : null;
        this.pk = pk != null ? pk : null;
        if (points == null) {
          points = null;
        }
        this.lock = lock != null ? lock : null;
        this.owner = owner != null ? owner : null;
        this.drawingId = drawingId != null ? drawingId : null;
        PixelPath.__super__.constructor.call(this, this.date, this.data, this.id, this.pk, points, this.lock, this.owner, this.drawingId);
        return;
      }

      PixelPath.prototype.setControlPath = function(points, planet) {
        var i, j, len, point;
        for (i = j = 0, len = points.length; j < len; i = ++j) {
          point = points[i];
          this.controlPath.add(Utils.CS.posOnPlanetToProject(point, planet));
        }
      };

      PixelPath.prototype.loadPath = function(points) {
        this.addControlPath();
        this.setControlPath(this.data.points, this.data.planet);
        this.rectangle = this.controlPath.bounds.clone();
        R.rasterizer.loadItem(this);
        if (!this.constructor.securePath) {
          return;
        }
      };

      PixelPath.prototype.performHitTest = function(point, options) {
        var hitResult;
        if (options == null) {
          options = this.constructor.hitOptions;
        }
        this.controlPath.visible = true;
        hitResult = this.controlPath.hitTest(point, options);
        this.controlPath.visible = false;
        return hitResult;
      };

      PixelPath.prototype.beginDraw = function(redrawing) {
        if (redrawing == null) {
          redrawing = false;
        }
        this.initializeDrawing(false);
      };

      PixelPath.prototype.updateDraw = function(segment, step, redrawing) {
        var circle;
        circle = this.addPath(new P.Path.Circle(segment.point, this.data.strokeWidth / 16));
        circle.fillColor = this.data.strokeColor;
      };

      PixelPath.prototype.endDraw = function(redrawing) {
        if (redrawing == null) {
          redrawing = false;
        }
      };

      PixelPath.prototype.checkUpdateDrawing = function(segment, redrawing) {
        if (redrawing == null) {
          redrawing = true;
        }
        this.updateDraw(segment);
      };

      PixelPath.prototype.beginCreate = function(point, event) {
        PixelPath.__super__.beginCreate.call(this);
        console.log('beginCreate');
        this.addControlPath();
        this.controlPath.add(Utils.Snap.snap2D(point, this.constructor.orthoGridSize));
        this.rectangle = this.controlPath.bounds.clone();
        this.beginDraw(false);
      };

      PixelPath.prototype.updateCreate = function(point, event) {
        var target;
        if (this.controlPath.lastSegment.point.getDistance(point, true) < 20) {
          return;
        }
        console.log('updateCreate');
        target = Utils.Snap.snap2D(point, this.constructor.orthoGridSize);
        this.controlPath.add(target);
        this.checkUpdateDrawing(this.controlPath.lastSegment, false);
      };

      PixelPath.prototype.createMove = function(event) {
        this.controlPath.lastSegment.point = event.point;
        console.log('create move');
        this.draw(true, false);
      };

      PixelPath.prototype.endCreate = function(point, event) {
        if (this.data.polygonMode) {
          return;
        }
        console.log('endCreate');
        this.finish();
        PixelPath.__super__.endCreate.call(this);
      };

      PixelPath.prototype.finish = function() {
        if (this.controlPath.segments.length < 2) {
          this.updateCreate(this.controlPath.firstSegment.point.add(new P.Point(0.25, 0.25)), null);
        }
        this.endDraw();
        this.draw();
        this.drawingOffset = 0;
        this.rectangle = this.controlPath.bounds.clone();
        if (!PixelPath.__super__.finish.call(this)) {
          return false;
        }
        this.initialize();
        return true;
      };

      PixelPath.prototype.processDrawing = function(redrawing) {
        var i, j, len, ref, segment;
        this.beginDraw(redrawing);
        ref = this.controlPath.segments;
        for (i = j = 0, len = ref.length; j < len; i = ++j) {
          segment = ref[i];
          if (i === 0) {
            continue;
          }
          this.checkUpdateDrawing(segment, redrawing);
        }
        this.endDraw(redrawing);
      };

      PixelPath.prototype.draw = function(simplified, redrawing) {
        var error, error1;
        if (simplified == null) {
          simplified = false;
        }
        if (redrawing == null) {
          redrawing = true;
        }
        if (this.drawn) {
          return;
        }
        if (!R.rasterizer.requestDraw(this, simplified, redrawing)) {
          return;
        }
        if (this.controlPath.segments.length < 2) {
          return;
        }
        if (simplified) {
          this.simplifiedModeOn();
        }
        this.drawingOffset = 0;
        try {
          this.processDrawing(redrawing);
        } catch (error1) {
          error = error1;
          console.error(error.stack);
          console.error(error);
          throw error;
        }
        if (simplified) {
          this.simplifiedModeOff();
        }
        this.drawn = true;
      };

      PixelPath.prototype.pathOnPlanet = function() {
        var flatennedPath;
        flatennedPath = this.controlPath.copyTo(P.project);
        flatennedPath.flatten(this.constructor.secureStep);
        flatennedPath.remove();
        return PixelPath.__super__.pathOnPlanet.call(this, flatennedPath.segments);
      };

      PixelPath.prototype.getPoints = function() {
        var j, len, points, ref, segment;
        points = [];
        ref = this.controlPath.segments;
        for (j = 0, len = ref.length; j < len; j++) {
          segment = ref[j];
          points.push(Utils.CS.projectToPosOnPlanet(segment.point));
          points.push(Utils.CS.pointToObj(segment.handleIn));
          points.push(Utils.CS.pointToObj(segment.handleOut));
          points.push(segment.rtype);
        }
        return points;
      };

      PixelPath.prototype.getPointsAndPlanet = function() {
        return {
          planet: this.getPlanet(),
          points: this.getPoints()
        };
      };

      PixelPath.prototype.getData = function() {
        this.data.planet = this.getPlanet();
        this.data.points = this.getPoints();
        return this.data;
      };

      PixelPath.prototype.select = function(updateOptions) {
        if (updateOptions == null) {
          updateOptions = true;
        }
        if (!PixelPath.__super__.select.call(this, updateOptions)) {
          return;
        }
        this.controlPath.selected = true;
        if (!this.data.smooth) {
          this.controlPath.fullySelected = true;
        }
        return true;
      };

      PixelPath.prototype.deselect = function(updateOptions) {
        var ref;
        if (updateOptions == null) {
          updateOptions = true;
        }
        if (!PixelPath.__super__.deselect.call(this, updateOptions)) {
          return false;
        }
        if ((ref = this.controlPath) != null) {
          ref.selected = false;
        }
        this.removeSelectionHighlight();
        return true;
      };

      PixelPath.prototype.highlightSelectedPoint = function() {
        var base, offset, point;
        if (!this.controlPath.selected) {
          return;
        }
        this.removeSelectionHighlight();
        if (this.selectedSegment == null) {
          return;
        }
        point = this.selectedSegment.point;
        if ((base = this.selectedSegment).rtype == null) {
          base.rtype = 'smooth';
        }
        switch (this.selectedSegment.rtype) {
          case 'smooth':
            this.selectionHighlight = new P.Path.Circle(point, 5);
            break;
          case 'corner':
            offset = new P.Point(5, 5);
            this.selectionHighlight = new P.Path.Rectangle(point.subtract(offset), point.add(offset));
            break;
          case 'point':
            this.selectionHighlight = new P.Path.RegularPolygon(point, 3, 5);
        }
        this.selectionHighlight.name = 'selection highlight';
        this.selectionHighlight.controller = this;
        this.selectionHighlight.strokeColor = R.selectionBlue;
        this.selectionHighlight.strokeWidth = 1;
        R.view.selectionLayer.addChild(this.selectionHighlight);
      };

      PixelPath.prototype.updateSelectionHighlight = function() {
        if ((this.selectedSegment != null) && this.selectionHighlight) {
          this.selectionHighlight.position = this.selectedSegment.point;
        }
      };

      PixelPath.prototype.removeSelectionHighlight = function() {
        var ref;
        if ((ref = this.selectionHighlight) != null) {
          ref.remove();
        }
        this.selectionHighlight = null;
      };

      PixelPath.prototype.moveTo = function(position, update) {
        PixelPath.__super__.moveTo.call(this, position, update);
        this.updateSelectionHighlight();
      };

      PixelPath.prototype.setRectangle = function(rectangle, update) {
        var previousRectangle;
        previousRectangle = this.rectangle.clone();
        PixelPath.__super__.setRectangle.call(this, rectangle, update);
        this.controlPath.pivot = previousRectangle.center;
        this.controlPath.rotate(-this.rotation);
        this.controlPath.scale(this.rectangle.width / previousRectangle.width, this.rectangle.height / previousRectangle.height);
        this.controlPath.position = this.rectangle.center.clone();
        this.controlPath.pivot = this.rectangle.center.clone();
        this.controlPath.rotate(this.rotation);
        this.updateSelectionHighlight();
      };

      PixelPath.prototype.setRotation = function(rotation, center, update) {
        PixelPath.__super__.setRotation.call(this, rotation, center, update);
        this.updateSelectionHighlight();
      };

      PixelPath.prototype.smoothPoint = function(segment, offset) {
        var tangent;
        segment.rtype = 'smooth';
        segment.linear = false;
        if (offset == null) {
          offset = segment.location.offset;
        }
        tangent = segment.path.getTangentAt(offset);
        if (segment.previous != null) {
          segment.handleIn = tangent.multiply(-0.25);
        }
        if (segment.next != null) {
          segment.handleOut = tangent.multiply(+0.25);
        }
      };

      PixelPath.prototype.doubleClick = function(event) {
        var hitResult, point, segment;
        point = P.view.viewToProject(Utils.Event.GetPoint(event));
        hitResult = this.performHitTest(point);
        if (hitResult == null) {
          return;
        }
        switch (hitResult.type) {
          case 'segment':
            segment = hitResult.segment;
            this.selectedSegment = segment;
            switch (segment.rtype) {
              case 'smooth':
              case null:
              case void 0:
                this.modifySelectedPointType('corner');
                break;
              case 'corner':
                this.modifySelectedPointType('point');
                break;
              case 'point':
                this.deletePointCommand();
                break;
              default:
                console.log("segment.rtype not known.");
            }
            break;
          case 'stroke':
          case 'curve':
            this.addPointCommand(hitResult.location);
        }
      };

      PixelPath.prototype.addPointCommand = function(location) {
        R.commandManager.add(new Command.AddPoint(this, location), true);
      };

      PixelPath.prototype.addPointAt = function(location, update) {
        if (update == null) {
          update = true;
        }
        if (!P.CurveLocation.prototype.isPrototypeOf(location)) {
          location = this.controlPath.getLocationAt(location);
        }
        return this.addPoint(location.index, location.point, location.offset, update);
      };

      PixelPath.prototype.addPoint = function(index, point, offset, update) {
        var segment;
        if (update == null) {
          update = true;
        }
        segment = this.controlPath.insert(index + 1, new P.Point(point));
        if (this.data.smooth) {
          this.controlPath.smooth();
        } else {
          this.smoothPoint(segment, offset);
        }
        this.draw();
        if (!this.socketAction) {
          segment.selected = true;
          this.selectedSegment = segment;
          this.highlightSelectedPoint();
          if (update) {
            this.update('point');
          }
          R.socket.emit("bounce", {
            itemId: this.id,
            "function": "addPoint",
            "arguments": [index, point, offset, false]
          });
        }
        return segment;
      };

      PixelPath.prototype.deletePointCommand = function() {
        if (this.selectedSegment == null) {
          return;
        }
        R.commandManager.add(new Command.DeletePoint(this, this.selectedSegment), true);
      };

      PixelPath.prototype.deletePoint = function(segment, update) {
        var location;
        if (update == null) {
          update = true;
        }
        if (!segment) {
          return;
        }
        if (!P.Segment.prototype.isPrototypeOf(segment)) {
          segment = this.controlPath.segments[segment];
        }
        this.selectedSegment = segment.next != null ? segment.next : segment.previous;
        if (this.selectedSegment != null) {
          this.highlightSelectedPoint();
        }
        location = {
          index: segment.location.index - 1,
          point: segment.location.pointÂ
        };
        segment.remove();
        if (this.controlPath.segments.length <= 1) {
          this.deleteCommand();
          return;
        }
        if (this.data.smooth) {
          this.controlPath.smooth();
        }
        this.draw();
        if (!this.socketAction) {
          R.tools.select.updateSelectionRectangle();
          if (update) {
            this.update('point');
          }
          R.socket.emit("bounce", {
            itemId: this.id,
            "function": "deletePoint",
            "arguments": [segment.index, false]
          });
        }
        return location;
      };

      PixelPath.prototype.deleteSelectedPoint = function() {
        this.deletePoint(this.selectedSegment);
      };

      PixelPath.prototype.modifySelectedPoint = function(position, handleIn, handleOut, fastDraw, update) {
        if (fastDraw == null) {
          fastDraw = true;
        }
        if (update == null) {
          update = true;
        }
        this.modifyPoint(this.selectedSegment, position, handleIn, handleOut, fastDraw, update);
      };

      PixelPath.prototype.modifyPoint = function(segment, position, handleIn, handleOut, fastDraw, update) {
        if (fastDraw == null) {
          fastDraw = true;
        }
        if (update == null) {
          update = true;
        }
        if (!P.Segment.prototype.isPrototypeOf(segment)) {
          segment = this.controlPath.segments[segment];
        }
        segment.point = new P.Point(position);
        segment.handleIn = new P.Point(handleIn);
        segment.handleOut = new P.Point(handleOut);
        this.rectangle = this.controlPath.bounds.clone();
        R.tools.select.updateSelectionRectangle();
        this.draw(fastDraw);
        if (this.selectionHighlight == null) {
          this.highlightSelectedPoint();
        } else {
          this.updateSelectionHighlight();
        }
        if (!this.socketAction) {
          if (update) {
            this.update('segment');
          }
          R.socket.emit("bounce", {
            itemId: this.id,
            "function": "modifyPoint",
            "arguments": [segment.index, position, handleIn, handleOut, fastDraw, false]
          });
        }
      };

      PixelPath.prototype.updateModifyPoint = function(event) {
        var handle, point, segment;
        segment = this.selectedSegment;
        handle = this.selectedHandle;
        if (handle != null) {
          if (Utils.Snap.getSnap() >= 1) {
            point = Utils.Snap.snap2D(event.point);
            handle.x = point.x - segment.point.x;
            handle.y = point.y - segment.point.y;
          } else {
            handle.x += event.delta.x;
            handle.y += event.delta.y;
          }
          if (segment.rtype === 'smooth' || (segment.rtype == null)) {
            if (handle === segment.handleOut && !segment.handleIn.isZero()) {
              if (!event.modifiers.shift) {
                segment.handleIn = segment.handleOut.normalize().multiply(-segment.handleIn.length);
              } else {
                segment.handleIn = segment.handleOut.multiply(-1);
              }
            }
            if (handle === segment.handleIn && !segment.handleOut.isZero()) {
              if (!event.modifiers.shift) {
                segment.handleOut = segment.handleIn.normalize().multiply(-segment.handleOut.length);
              } else {
                segment.handleOut = segment.handleIn.multiply(-1);
              }
            }
          }
        } else if (segment != null) {
          if (Utils.Snap.getSnap() >= 1) {
            point = Utils.Snap.snap2D(event.point);
            segment.point.x = point.x;
            segment.point.y = point.y;
          } else {
            segment.point.x += event.delta.x;
            segment.point.y += event.delta.y;
          }
        }
        Item.Lock.highlightValidity(this, null, true);
        this.modifyPoint(segment, segment.point, segment.handleIn, segment.handleOut, true, false);
      };

      PixelPath.prototype.endModifyPoint = function(update) {
        var ref;
        if (update) {
          if (this.data.smooth) {
            this.controlPath.smooth();
          }
          this.draw();
          this.rasterize();
          if ((ref = this.selectionHighlight) != null) {
            ref.bringToFront();
          }
          this.update('points');
        }
      };

      PixelPath.prototype.modifyPointTypeCommand = function(rtype) {
        R.commandManager.add(new Command.ModifyPointType(this, this.selectedSegment, rtype), true);
      };

      PixelPath.prototype.modifySelectedPointType = function(value, update) {
        if (update == null) {
          update = true;
        }
        if (this.selectedSegment == null) {
          return;
        }
        this.modifyPointType(this.selectedSegment, value, update);
      };

      PixelPath.prototype.modifyPointType = function(segment, rtype, update) {
        if (update == null) {
          update = true;
        }
        if (!P.Segment.prototype.isPrototypeOf(segment)) {
          segment = this.controlPath.segments[segment];
        }
        if (this.data.smooth) {
          return;
        }
        this.selectedSegment.rtype = rtype;
        switch (rtype) {
          case 'corner':
            if (this.selectedSegment.linear = true) {
              this.selectedSegment.linear = false;
              this.selectedSegment.handleIn = this.selectedSegment.previous != null ? this.selectedSegment.previous.point.subtract(this.selectedSegment.point).multiply(0.5) : null;
              this.selectedSegment.handleOut = this.selectedSegment.next != null ? this.selectedSegment.next.point.subtract(this.selectedSegment.point).multiply(0.5) : null;
            }
            break;
          case 'point':
            this.selectedSegment.linear = true;
            break;
          case 'smooth':
            this.smoothPoint(this.selectedSegment);
        }
        this.draw();
        this.highlightSelectedPoint();
        if (!this.socketAction) {
          if (update) {
            this.update('point');
          }
          R.socket.emit("bounce", {
            itemId: this.id,
            "function": "modifyPointType",
            "arguments": [segment.index, rtype, false]
          });
        }
      };

      PixelPath.prototype.modifyControlPathCommand = function(previousPointsAndPlanet, newPointsAndPlanet) {
        R.commandManager.add(new Command.ModifyControlPath(this, previousPointsAndPlanet, newPointsAndPlanet), false);
      };

      PixelPath.prototype.modifyControlPath = function(pointsAndPlanet, update) {
        var fullySelected, selected;
        if (update == null) {
          update = true;
        }
        selected = this.controlPath.selected;
        fullySelected = this.controlPath.fullySelected;
        this.controlPath.removeSegments();
        this.setControlPath(pointsAndPlanet.points, pointsAndPlanet.planet);
        this.controlPath.selected = selected;
        if (fullySelected) {
          this.controlPath.fullySelected = true;
        }
        this.deselectPoint();
        this.draw();
        if (!this.socketAction) {
          if (update) {
            this.update('point');
          }
          R.socket.emit("bounce", {
            itemId: this.id,
            "function": "modifyControlPath",
            "arguments": [pointsAndPlanet, false]
          });
        }
      };

      PixelPath.prototype.setSmooth = function(smooth) {
        var j, len, previousPointsAndPlanet, ref, segment;
        this.data.smooth = smooth;
        if (this.data.smooth) {
          previousPointsAndPlanet = this.getPointsAndPlanet();
          this.controlPath.smooth();
          this.controlPath.fullySelected = false;
          this.controlPath.selected = true;
          this.deselectPoint();
          ref = this.controlPath.segments;
          for (j = 0, len = ref.length; j < len; j++) {
            segment = ref[j];
            segment.rtype = 'smooth';
          }
          this.draw();
          this.modifyControlPathCommand(previousPointsAndPlanet, this.getPointsAndPlanet());
        } else {
          this.controlPath.fullySelected = true;
          this.highlightSelectedPoint();
        }
      };

      PixelPath.prototype.simplifyControlPath = function() {
        var previousPointsAndPlanet, ref;
        previousPointsAndPlanet = this.getPointsAndPlanet();
        if ((ref = this.controlPath) != null) {
          ref.simplify();
        }
        this.draw();
        this.update();
        this.modifyControlPathCommand(previousPointsAndPlanet, this.getPointsAndPlanet());
      };

      PixelPath.prototype.setParameter = function(name, value, updateGUI, update) {
        PixelPath.__super__.setParameter.call(this, name, value, updateGUI, update);
      };

      PixelPath.prototype.remove = function() {
        var ref;
        console.log("Remove precise path");
        if ((ref = this.canvasRaster) != null) {
          ref.remove();
        }
        this.canvasRaster = null;
        if (this.liJ != null) {
          this.removeFromListItem();
        }
        PixelPath.__super__.remove.call(this);
      };

      return PixelPath;

    })(Path);
    Item.PrecisePath = PrecisePath;
    return PrecisePath;
  });

}).call(this);

//# sourceMappingURL=PixelPath.js.map
