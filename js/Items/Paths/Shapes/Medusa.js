// Generated by CoffeeScript 1.12.7
(function() {
  var bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  define(['paper', 'R', 'Utils/Utils', 'Items/Paths/Shapes/Shape'], function(P, R, Utils, Shape) {
    var Medusa;
    Medusa = (function(superClass) {
      extend(Medusa, superClass);

      function Medusa() {
        this.onFrame = bind(this.onFrame, this);
        return Medusa.__super__.constructor.apply(this, arguments);
      }

      Medusa.Shape = P.Path.Rectangle;

      Medusa.label = 'Medusa';

      Medusa.description = "Creates a bunch of aniamted Medusa.";

      Medusa.squareByDefault = true;

      Medusa.initializeParameters = function() {
        var parameters;
        parameters = Medusa.__super__.constructor.initializeParameters.call(this);
        if (parameters['Parameters'] == null) {
          parameters['Parameters'] = {};
        }
        parameters['Parameters'].stripeWidth = {
          type: 'slider',
          label: 'Stripe width',
          min: 1,
          max: 5,
          "default": 1
        };
        parameters['Parameters'].maskWidth = {
          type: 'slider',
          label: 'Mask width',
          min: 1,
          max: 4,
          "default": 1
        };
        parameters['Parameters'].speed = {
          type: 'slider',
          label: 'Speed',
          min: 0.01,
          max: 1.0,
          "default": 0.1
        };
        return parameters;
      };

      Medusa.parameters = Medusa.initializeParameters();

      Medusa.createTool(Medusa);

      Medusa.prototype.initialize = function() {
        this.data.animate = true;
        this.setAnimated(this.data.animate);
      };

      Medusa.prototype.createShape = function() {
        var i, j, k, l, normal, point, position, ref, ref1, step, tentacle, topSegment;
        this.data.nTentacles;
        this.data.nSegments;
        this.data.pulsePeriod;
        this.data.elasticConstant;
        this.path = this.addPath();
        topSegment = new P.Segment(this.rectangle.center.x, this.rectangle.top);
        topSegment.handleIn = new P.Point(-this.rectangle.width / 3, 0);
        topSegment.handleOut = new P.Point(this.rectangle.width / 3, 0);
        this.path.add(topSegment);
        this.leftSegment = new P.Segment(this.rectangle.left, this.rectangle.top + this.rectangle.height * 0.7);
        this.leftSegment.handleIn = new P.Point(0, -this.rectangle.height * 0.5);
        this.leftSegment.handleOut = new P.Point(0, this.rectangle.height * 0.3);
        this.path.add(this.leftSegment);
        this.rightSegment = new P.Segment(this.rectangle.right, this.rectangle.top + this.rectangle.height * 0.7);
        this.rightSegment.handleIn = new P.Point(0, -this.rectangle.height * 0.5);
        this.rightSegment.handleOut = new P.Point(0, this.rectangle.height * 0.3);
        this.path.add(this.rightSegment);
        position = this.leftSegment.location.offset;
        step = (this.rightSegment.location.offset - this.leftSegment.location.offset) / nTentacles;
        this.tentacles = [];
        for (i = k = 0, ref = nTentacles; 0 <= ref ? k <= ref : k >= ref; i = 0 <= ref ? ++k : --k) {
          console.log("draw tentacle");
          point = this.path.getPointAt(position);
          normal = this.path.getNormalAt(position);
          tentacle = this.addPath();
          tentacle.add(point);
          for (j = l = 0, ref1 = nSegments; 0 <= ref1 ? l <= ref1 : l >= ref1; j = 0 <= ref1 ? ++l : --l) {
            tentacle.add(point.add(normal.multiply(j)));
          }
          this.tentacles.push(tentacle);
          position += step;
        }
      };

      Medusa.prototype.onFrame = function(event) {
        var delta, direction, force, k, l, lastPoint, len, len1, normal, position, ref, ref1, segment, step, tentacle, time;
        direction = new P.Point(1, 0);
        direction.angle = this.rotation;
        normal = direction.clone();
        normal.angle += 90;
        force = null;
        time = Date.now();
        if (time > this.lastUpdate + this.data.pulsePeriod) {
          this.lastUpdate = time;
          force = normal.multiply(this.data.pulseAmplitude);
        } else {
          force = normal.multiply(-0.1 * this.data.pulseAmplitude);
        }
        this.leftSegment.point = this.leftSegment.point.add(force);
        this.rightSegment.point = this.rightSegment.point.subtract(force);
        position = this.leftSegment.location.offset;
        step = (this.rightSegment.location.offset - this.leftSegment.location.offset) / nTentacles;
        ref = this.tentacles;
        for (k = 0, len = ref.length; k < len; k++) {
          tentacle = ref[k];
          lastPoint = this.path.getPointAt(position);
          ref1 = tentacle.segments;
          for (l = 0, len1 = ref1.length; l < len1; l++) {
            segment = ref1[l];
            delta = lastPoint.subtract(segment.point);
            segment.point.translate(delta.multiply(this.data.elasticConstant));
            lastPoint = segment.point;
          }
          position += step;
        }
      };

      return Medusa;

    })(Shape);
    return Medusa;
  });

}).call(this);
