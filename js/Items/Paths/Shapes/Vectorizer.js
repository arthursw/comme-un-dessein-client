// Generated by CoffeeScript 1.10.0
(function() {
  var bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  define(['Items/Paths/Shapes/Shape', 'UI/Modal'], function(Shape, Modal) {
    var Vectorizer;
    Vectorizer = (function(superClass) {
      extend(Vectorizer, superClass);

      function Vectorizer() {
        this.allRastersLoaded = bind(this.allRastersLoaded, this);
        return Vectorizer.__super__.constructor.apply(this, arguments);
      }

      Vectorizer.Shape = P.Path.Rectangle;

      Vectorizer.label = 'Vectorizer';

      Vectorizer.description = "Creates a vectorized version of an image.";

      Vectorizer.squareByDefault = true;

      Vectorizer.initializeParameters = function() {
        var parameters;
        parameters = Vectorizer.__super__.constructor.initializeParameters.call(this);
        parameters['Style'].strokeWidth["default"] = 1;
        parameters['Style'].strokeColor["default"] = 'black';
        parameters['Style'].strokeColor.defaultFunction = null;
        if (parameters['Parameters'] == null) {
          parameters['Parameters'] = {};
        }
        parameters['Parameters'].effectType = {
          "default": 'multipleStrokes',
          values: ['multipleStrokes', 'color', 'blackAndWhite', 'CMYKstripes', 'CMYKdots'],
          label: 'Effect type'
        };
        parameters['Parameters'].nStrokes = {
          type: 'slider',
          label: 'StrokeNumber',
          min: 2,
          max: 16,
          "default": 4
        };
        parameters['Parameters'].spiralWidth = {
          type: 'slider',
          label: 'Spiral width',
          min: 1,
          max: 16,
          "default": 7
        };
        parameters['Parameters'].pixelSize = {
          type: 'slider',
          label: 'pixelSize',
          min: 1,
          max: 16,
          "default": 7
        };
        parameters['Parameters'].nStripes = {
          type: 'slider',
          label: 'nStripes',
          min: 10,
          max: 160,
          "default": 15
        };
        parameters['Parameters'].blackThreshold = {
          type: 'slider',
          label: 'blackThreshold',
          min: 0,
          max: 255,
          "default": 50
        };
        parameters['Parameters'].cyanThreshold = {
          type: 'slider',
          label: 'cyanThreshold',
          min: 0,
          max: 255,
          "default": 128
        };
        parameters['Parameters'].magentaThreshold = {
          type: 'slider',
          label: 'magentaThreshold',
          min: 0,
          max: 255,
          "default": 128
        };
        parameters['Parameters'].yellowThreshold = {
          type: 'slider',
          label: 'yellowThreshold',
          min: 0,
          max: 255,
          "default": 128
        };
        parameters['Parameters'].blackAngle = {
          type: 'slider',
          label: 'blackAngle',
          min: 0,
          max: 360,
          "default": 45
        };
        parameters['Parameters'].cyanAngle = {
          type: 'slider',
          label: 'cyanAngle',
          min: 0,
          max: 360,
          "default": 15
        };
        parameters['Parameters'].magentaAngle = {
          type: 'slider',
          label: 'magentaAngle',
          min: 0,
          max: 360,
          "default": 75
        };
        parameters['Parameters'].yellowAngle = {
          type: 'slider',
          label: 'yellowAngle',
          min: 0,
          max: 360,
          "default": 0
        };
        parameters['Parameters'].dotSize = {
          type: 'slider',
          label: 'dotSize',
          min: 0.1,
          max: 10,
          "default": 2
        };
        return parameters;
      };

      Vectorizer.parameters = Vectorizer.initializeParameters();

      Vectorizer.createTool(Vectorizer);

      Vectorizer.prototype.initialize = function() {
        var modal;
        if (!(window.File && window.FileReader && window.FileList && window.Blob)) {
          console.log('File upload not supported.');
          R.alertManager.alert('File upload not supported', 'error');
          return;
        }
        modal = Modal.createModal({
          title: 'Select an image',
          submit: function() {}
        });
        modal.addImageSelector({
          name: "image-selector",
          rastersLoadedCallback: this.allRastersLoaded,
          extractor: (function(_this) {
            return function() {
              return _this.rasters.length > 0;
            };
          })(this)
        });
        modal.show();
      };

      Vectorizer.prototype.allRastersLoaded = function(rasters) {
        var file, raster;
        if (((this.rasters == null) || this.rasters.length === 0) && (rasters == null)) {
          return;
        }
        if (this.rasters == null) {
          this.rasters = [];
          for (file in rasters) {
            raster = rasters[file];
            this.rasters.push(raster);
          }
        }
        switch (this.data.effectType) {
          case 'multipleStrokes':
            this.drawSpiralMultipleStrokes();
            break;
          case 'color':
            this.drawSpiralColor();
            break;
          case 'blackAndWhite':
            this.drawSpiralColor(true);
            break;
          case 'CMYKstripes':
            this.drawCMYKstripes();
            break;
          case 'CMYKdots':
            this.drawCMYKdots();
        }
      };

      Vectorizer.prototype.drawSpiralColor = function(blackAndWhite) {
        var c, color, colors, count, l, len, len1, m, offset, offsets, path, position, raster, ref, rot, v, value, vector;
        if (blackAndWhite == null) {
          blackAndWhite = false;
        }
        raster = this.rasters[0];
        raster.fitBounds(this.rectangle, true);
        raster.visible = false;
        colors = blackAndWhite ? ['black'] : ['red', 'green', 'blue'];
        offsets = blackAndWhite ? {
          'black': 0
        } : {
          'red': -3.7 / 1.5,
          'green': 0,
          'blue': 3.7 / 1.5
        };
        this.paths = {};
        for (l = 0, len = colors.length; l < len; l++) {
          color = colors[l];
          path = this.addPath(new P.Path());
          path.fillColor = color;
          path.strokeColor = null;
          path.strokeWidth = 0;
          path.closed = true;
          this.paths[color] = path;
        }
        position = this.rectangle.center;
        count = 0;
        while (this.rectangle.center.subtract(position).length < this.rectangle.width / 2) {
          vector = new P.Point({
            angle: count * 5,
            length: count / 100
          });
          rot = vector.rotate(90);
          offset = rot.clone();
          offset.length = 1;
          color = raster.getAverageColor(position.add(vector.divide(2)));
          for (m = 0, len1 = colors.length; m < len1; m++) {
            c = colors[m];
            v = blackAndWhite ? color.gray : color[c];
            value = color ? (1 - v) * this.data.spiralWidth / 2.5 : 0;
            rot.length = Math.max(value, 0.1);
            this.paths[c].add(position.add(vector).add(offset.multiply(offsets[c])).subtract(rot));
            this.paths[c].insert(0, position.add(vector).add(offset.multiply(offsets[c])).add(rot));
          }
          position = position.add(vector);
          count++;
        }
        ref = this.paths;
        for (color in ref) {
          path = ref[color];
          path.smooth();
        }
      };

      Vectorizer.prototype.drawSpiralMultipleStrokes = function() {
        var color, count, i, l, len, len1, m, n, offset, path, position, raster, ref, ref1, ref2, rot, step, value, vector;
        raster = this.rasters[0];
        raster.fitBounds(this.rectangle, true);
        raster.visible = false;
        this.paths = [];
        for (i = l = 1, ref = this.data.nStrokes; 1 <= ref ? l <= ref : l >= ref; i = 1 <= ref ? ++l : --l) {
          path = this.addPath(new P.Path());
          path.strokeColor = this.data.strokeColor;
          path.strokeWidth = this.data.strokeWidth;
          path.closed = false;
          this.paths.push(path);
        }
        position = this.rectangle.center;
        count = 0;
        while (this.rectangle.center.subtract(position).length < this.rectangle.width / 2) {
          vector = new P.Point({
            angle: count * 5,
            length: count / 100
          });
          rot = vector.rotate(90);
          offset = rot.clone();
          offset.length = 1;
          color = raster.getAverageColor(position.add(vector.divide(2)));
          value = color ? (1 - color.gray) * this.data.spiralWidth / 2.5 : 0;
          rot.length = Math.max(value, 0.1);
          offset = -1;
          step = 2 / this.paths.length;
          ref1 = this.paths;
          for (m = 0, len = ref1.length; m < len; m++) {
            path = ref1[m];
            path.add(position.add(vector).add(rot.multiply(offset)));
            offset += step;
          }
          position = position.add(vector);
          count++;
        }
        ref2 = this.paths;
        for (n = 0, len1 = ref2.length; n < len1; n++) {
          path = ref2[n];
          path.smooth();
        }
      };

      Vectorizer.prototype.colorToCMYK = function(color) {
        var b, g, k, r, result;
        r = color.red;
        g = color.green;
        b = color.blue;
        k = Math.min(1 - r, 1 - g, 1 - b);
        result = {
          c: (1 - r - k) / (1 - k) || 0,
          m: (1 - g - k) / (1 - k) || 0,
          y: (1 - b - k) / (1 - k) || 0,
          k: k
        };
        return result;
      };

      Vectorizer.prototype.drawCMYKdots = function() {
        var angle, c, center, color, colors, colorsToAngles, colorsToNames, colorsToThreshold, cymk, deltaX, deltaY, dot, i, j, l, len, m, maxSize, n, nSteps, path, pixel, position, previousColor, raster, ref, ref1, square, startPosition;
        raster = this.rasters[0];
        raster.fitBounds(this.rectangle, true);
        raster.visible = false;
        maxSize = Math.max(this.rectangle.width, this.rectangle.height);
        square = new P.Rectangle(maxSize, maxSize);
        pixel = new P.Rectangle(-this.data.pixelSize / 2, -this.data.pixelSize / 2, this.data.pixelSize, this.data.pixelSize);
        nSteps = maxSize / this.data.pixelSize;
        colorsToNames = {
          c: 'cyan',
          m: 'magenta',
          y: 'yellow',
          k: 'black'
        };
        colorsToAngles = {
          c: this.data.cyanAngle,
          m: this.data.magentaAngle,
          y: this.data.yellowAngle,
          k: this.data.blackAngle
        };
        colorsToThreshold = {
          c: this.data.cyanThreshold,
          m: this.data.magentaThreshold,
          y: this.data.yellowThreshold,
          k: this.data.blackThreshold
        };
        colors = ['k', 'm', 'c', 'y'];
        for (l = 0, len = colors.length; l < len; l++) {
          c = colors[l];
          angle = colorsToAngles[c];
          center = this.rectangle.center;
          position = center.subtract(maxSize / 2);
          position = position.rotate(angle, center);
          deltaX = new P.Point(1, 0).rotate(angle).multiply(this.data.pixelSize);
          deltaY = new P.Point(0, 1).rotate(angle).multiply(this.data.pixelSize);
          previousColor = null;
          path = null;
          for (i = m = 0, ref = nSteps; 0 <= ref ? m <= ref : m >= ref; i = 0 <= ref ? ++m : --m) {
            startPosition = position.clone();
            if (i % 2 === 0) {
              position = position.add(deltaX.divide(2));
            }
            for (j = n = 0, ref1 = nSteps; 0 <= ref1 ? n <= ref1 : n >= ref1; j = 0 <= ref1 ? ++n : --n) {
              if (position.x === 0) {
                position.x = 0.001;
              }
              color = raster.getAverageColor(position);
              if (color != null) {
                cymk = this.colorToCMYK(color);
                dot = this.addPath(new P.Path.Circle(position, cymk[c] * this.data.pixelSize * this.data.dotSize));
                dot.fillColor = colorsToNames[c];
                dot.strokeWidth = 0;
              }
              position = position.add(deltaX);
            }
            position = startPosition.add(deltaY);
          }
        }
      };

      Vectorizer.prototype.drawCMYKstripes = function() {
        var angle, angles, c, center, color, colors, colorsToAngles, colorsToNames, colorsToThreshold, cymk, deltaX, deltaY, i, j, l, len, m, maxSize, n, nSteps, path, pixel, position, previousColor, previousPosition, raster, ref, ref1, square, startPosition, yStepSize;
        raster = this.rasters[0];
        raster.fitBounds(this.rectangle, true);
        raster.visible = false;
        maxSize = Math.max(this.rectangle.width, this.rectangle.height);
        square = new P.Rectangle(maxSize, maxSize);
        pixel = new P.Rectangle(-this.data.pixelSize / 2, -this.data.pixelSize / 2, this.data.pixelSize, this.data.pixelSize);
        nSteps = maxSize / this.data.pixelSize;
        yStepSize = maxSize / this.data.nStripes;
        colorsToNames = {
          c: 'cyan',
          m: 'magenta',
          y: 'yellow',
          k: 'black'
        };
        colorsToAngles = {
          c: this.data.cyanAngle,
          m: this.data.magentaAngle,
          y: this.data.yellowAngle,
          k: this.data.blackAngle
        };
        colorsToThreshold = {
          c: this.data.cyanThreshold,
          m: this.data.magentaThreshold,
          y: this.data.yellowThreshold,
          k: this.data.blackThreshold
        };
        colors = ['k', 'm', 'c', 'y'];
        angles = [15, 75, 0, 45];
        for (l = 0, len = colors.length; l < len; l++) {
          c = colors[l];
          angle = colorsToAngles[c];
          center = this.rectangle.center;
          position = center.subtract(maxSize / 2);
          center = this.rectangle.center;
          position = position.rotate(angle, center);
          deltaX = new P.Point(1, 0).rotate(angle).multiply(this.data.pixelSize);
          deltaY = new P.Point(0, 1).rotate(angle).multiply(yStepSize);
          previousColor = null;
          path = null;
          for (i = m = 0, ref = this.data.nStripes; 0 <= ref ? m <= ref : m >= ref; i = 0 <= ref ? ++m : --m) {
            startPosition = position.clone();
            for (j = n = 0, ref1 = nSteps; 0 <= ref1 ? n <= ref1 : n >= ref1; j = 0 <= ref1 ? ++n : --n) {
              if (position.x === 0) {
                position.x = 0.001;
              }
              color = raster.getAverageColor(new P.Rectangle(position.subtract(this.data.pixelSize / 2), new P.Size(this.data.pixelSize, this.data.pixelSize)));
              if (color != null) {
                cymk = this.colorToCMYK(color);
                if (cymk[c] > (colorsToThreshold[c] / 255)) {
                  if (path == null) {
                    path = this.addPath(new P.Path());
                    path.strokeColor = colorsToNames[c];
                    path.strokeWidth = this.data.spiralWidth;
                    path.add(position);
                  }
                } else if (path != null) {
                  path.add(previousPosition);
                  path = null;
                }
              }
              previousPosition = position.clone();
              position = position.add(deltaX);
            }
            path = null;
            previousPosition = position.clone();
            position = startPosition.add(deltaY);
          }
        }
      };

      Vectorizer.prototype.createShape = function() {
        this.shape = new P.Group();
        this.allRastersLoaded();
      };

      return Vectorizer;

    })(Shape);
    return Vectorizer;
  });

}).call(this);
