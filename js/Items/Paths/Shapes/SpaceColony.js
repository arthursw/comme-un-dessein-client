// Generated by CoffeeScript 1.10.0
(function() {
  var bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  define(['paper', 'R', 'Utils/Utils', 'Items/Paths/Shapes/Shape'], function(P, R, Utils, Shape) {
    var SpaceColony;
    SpaceColony = (function(superClass) {
      extend(SpaceColony, superClass);

      function SpaceColony() {
        this.sendToSpacebrew = bind(this.sendToSpacebrew, this);
        this.onFrame2 = bind(this.onFrame2, this);
        this.onFrame = bind(this.onFrame, this);
        this.drawTree = bind(this.drawTree, this);
        return SpaceColony.__super__.constructor.apply(this, arguments);
      }

      SpaceColony.Shape = P.Path.Rectangle;

      SpaceColony.label = 'Space colony';

      SpaceColony.description = "Space colony animation.";

      SpaceColony.squareByDefault = false;

      SpaceColony.initializeParameters = function() {
        var parameters;
        parameters = SpaceColony.__super__.constructor.initializeParameters.call(this);
        if (parameters['Parameters'] == null) {
          parameters['Parameters'] = {};
        }
        parameters['Style'].animate = {
          type: 'checkbox',
          label: 'Animate',
          "default": true
        };
        parameters['Parameters'].delay = {
          type: 'slider',
          label: 'Delay',
          min: 0,
          max: 300,
          "default": 0
        };
        parameters['Parameters'].nodeRadius = {
          type: 'slider',
          label: 'Node radius',
          min: 1,
          max: 100,
          "default": 4
        };
        parameters['Parameters'].pointSelectionDist = {
          type: 'slider',
          label: 'Selection dist',
          min: 1,
          max: 300,
          "default": 35
        };
        parameters['Parameters'].pointDeletionDist = {
          type: 'slider',
          label: 'Deletion dist',
          min: 1,
          max: 300,
          "default": 4
        };
        parameters['Parameters'].nPoints = {
          type: 'slider',
          label: 'Num. points',
          min: 100,
          max: 1000,
          "default": 1000
        };
        parameters['Parameters'].branching = {
          type: 'slider',
          label: 'Branching',
          min: 0,
          max: 100,
          "default": 50
        };
        parameters['Parameters'].scaleTree = {
          type: 'slider',
          label: 'Scale',
          min: 0,
          max: 500,
          "default": 100
        };
        parameters['Parameters'].pauseTree = {
          type: 'checkbox',
          label: 'Pause',
          "default": false,
          onChange: function() {
            var item, j, len, ref;
            ref = R.selectedItems;
            for (j = 0, len = ref.length; j < len; j++) {
              item = ref[j];
              item.data.pauseTree = !item.data.pauseTree;
            }
          }
        };
        return parameters;
      };

      SpaceColony.parameters = SpaceColony.initializeParameters();

      SpaceColony.createTool(SpaceColony);

      SpaceColony.prototype.initialize = function() {
        this.setAnimated(this.data.animate);
      };

      SpaceColony.prototype.createShape = function() {
        var i, j, ref, ref1, ref2, root;
        SpaceColony.__super__.createShape.call(this);
        if ((ref = this.pointGroup) != null) {
          ref.remove();
        }
        if ((ref1 = this.nodeGroup) != null) {
          ref1.remove();
        }
        this.pointGroup = new paper.Group();
        this.nodeGroup = new paper.Group();
        this.points = [];
        this.nodes = [];
        this.nFrame = 0;
        this.animating = true;
        for (i = j = 0, ref2 = this.data.nPoints; 0 <= ref2 ? j <= ref2 : j >= ref2; i = 0 <= ref2 ? ++j : --j) {
          this.points.push({
            point: new paper.Point.random().multiply(new paper.Point(this.rectangle.size)).add(this.rectangle.topLeft),
            closestNode: null
          });
        }
        this.points.push({
          point: this.rectangle.center,
          closestNode: null
        });
        root = {
          point: this.rectangle.center,
          age: 0,
          alive: true,
          growCount: 0,
          growDirection: new paper.Point(0, 0)
        };
        root.parent = root;
        this.nodes.push(root);
        this.aliveNodes = [root];
        this.drawTree();
        this.setAnimated(this.data.animate);
      };

      SpaceColony.prototype.drawTree = function() {
        var circle, j, k, len, len1, node, path, point, ref, ref1;
        this.pointGroup.removeChildren();
        this.nodeGroup.removeChildren();
        ref = this.points;
        for (j = 0, len = ref.length; j < len; j++) {
          point = ref[j];
          circle = new paper.Path.Circle(point.point, 2);
          circle.strokeWidth = 1;
          circle.strokeColor = 'black';
          this.pointGroup.addChild(circle);
        }
        ref1 = this.nodes;
        for (k = 0, len1 = ref1.length; k < len1; k++) {
          node = ref1[k];
          path = new paper.Path();
          path.add(node.point);
          path.add(node.parent.point);
          path.strokeWidth = node.age;
          path.strokeColor = node.alive ? 'purple' : 'black';
          path.strokeCap = 'round';
          this.nodeGroup.addChild(path);
          node.age = 1;
        }
      };

      SpaceColony.prototype.onFrame = function(event) {
        var averageDirection, direction, distance, i, j, k, l, len, len1, len2, newAliveNodes, newNode, newNodes, node, nodeAdded, point, ref, ref1, ref2;
        if ((!this.animating) || this.data.pauseTree) {
          return;
        }
        this.nFrame++;
        if (this.nFrame < this.data.delay) {
          return;
        } else {
          this.nFrame = 0;
        }
        ref = this.points;
        for (i = j = 0, len = ref.length; j < len; i = ++j) {
          point = ref[i];
          point.closestNode = null;
          point.closestNodeDistance = 0;
          ref1 = this.aliveNodes;
          for (k = 0, len1 = ref1.length; k < len1; k++) {
            node = ref1[k];
            direction = point.point.subtract(node.point);
            distance = direction.length;
            if (distance < this.data.pointDeletionDist) {
              this.points[i] = null;
            } else if (distance < this.data.pointSelectionDist) {
              if (point.closestNode == null) {
                point.closestNode = node;
                point.closestNodeDistance = distance;
              } else if (point.closestNodeDistance > distance) {
                point.closestNode = node;
                point.closestNodeDistance = distance;
              }
            }
          }
          if (point.closestNode != null) {
            direction = point.point.subtract(point.closestNode.point);
            direction = direction.normalize();
            point.closestNode.growDirection = point.closestNode.growDirection.add(direction);
            point.closestNode.growCount++;
          }
        }
        this.points = this.points.filter(function(p) {
          return p != null;
        });
        nodeAdded = false;
        newNodes = [];
        newAliveNodes = [];
        ref2 = this.aliveNodes;
        for (l = 0, len2 = ref2.length; l < len2; l++) {
          node = ref2[l];
          if (node.growCount > 0) {
            averageDirection = node.growDirection.divide(node.growCount);
            averageDirection = averageDirection.normalize();
            newNode = {
              parent: node,
              point: node.point.add(averageDirection.multiply(this.data.nodeRadius)),
              growDirection: averageDirection,
              growCount: 0,
              age: 0,
              alive: true
            };
            newNodes.push(newNode);
            newAliveNodes.push(newNode);
            node.growCount = 0;
            node.growDirection = new paper.Point(0, 0);
            nodeAdded = true;
            newAliveNodes.push(node);
          } else {
            node.alive = false;
          }
        }
        this.aliveNodes = newAliveNodes;
        this.nodes = this.nodes.concat(newNodes);
        if (!nodeAdded) {
          this.animating = false;
          console.log("ANIMATION FINISHED");
        }
        this.drawTree();
      };

      SpaceColony.prototype.onFrame2 = function(event) {
        var averageDirection, circle, closestPoint, closestPoints, distance, i, j, k, l, len, len1, len2, len3, len4, len5, m, n, nNodeAdded, newPoints, node, o, path, point, pointToRemoveIndex, pointsToRemove, ref, ref1, ref2, ref3, ref4;
        if (!this.animating) {
          return;
        }
        this.nFrame++;
        if (this.nFrame < this.data.delay) {
          return;
        } else {
          this.nFrame = 0;
        }
        nNodeAdded = 0;
        pointsToRemove = [];
        ref = this.nodes;
        for (j = 0, len = ref.length; j < len; j++) {
          node = ref[j];
          if (!node.alive) {
            continue;
          }
          closestPoints = [];
          ref1 = this.points;
          for (i = k = 0, len1 = ref1.length; k < len1; i = ++k) {
            point = ref1[i];
            distance = point.point.subtract(node.point).length;
            if (distance < this.data.pointSelectionDist) {
              closestPoints.push(point);
              if (distance < this.data.pointDeletionDist) {
                pointsToRemove.push(i);
              }
            }
          }
          if (closestPoints.length > 0) {
            averageDirection = new paper.Point(0, 0);
            for (l = 0, len2 = closestPoints.length; l < len2; l++) {
              closestPoint = closestPoints[l];
              averageDirection = averageDirection.add(closestPoint.subtract(node.point));
            }
            averageDirection = averageDirection.divide(closestPoints.length);
            averageDirection = averageDirection.normalize();
            this.nodes.push({
              point: node.point.add(averageDirection.multiply(2 * this.data.nodeRadius)),
              parent: node,
              age: 0,
              alive: true
            });
            nNodeAdded++;
          } else {
            node.alive = false;
          }
        }
        if (nNodeAdded === 0) {
          this.animating = false;
          console.log("ANIMATION FINISHED");
          return;
        }
        pointsToRemove = pointsToRemove.sort(function(a, b) {
          return a - b;
        }).filter(function(item, pos, array) {
          return !pos || item !== array[pos - 1];
        });
        newPoints = [];
        pointToRemoveIndex = 0;
        ref2 = this.points;
        for (i = m = 0, len3 = ref2.length; m < len3; i = ++m) {
          point = ref2[i];
          if (i !== pointsToRemove[pointToRemoveIndex]) {
            newPoints.push(point);
          } else {
            pointToRemoveIndex++;
          }
        }
        this.points = newPoints;
        this.pointGroup.removeChildren();
        this.nodeGroup.removeChildren();
        ref3 = this.points;
        for (n = 0, len4 = ref3.length; n < len4; n++) {
          point = ref3[n];
          circle = new paper.Path.Circle(point.point, 2);
          circle.strokeWidth = 1;
          circle.strokeColor = 'black';
          this.pointGroup.addChild(circle);
        }
        ref4 = this.nodes;
        for (o = 0, len5 = ref4.length; o < len5; o++) {
          node = ref4[o];
          path = new paper.Path();
          path.add(node.point);
          path.add(node.parent.point);
          path.strokeWidth = node.age;
          path.strokeColor = 'black';
          path.strokeCap = 'round';
          this.nodeGroup.addChild(path);
          node.age += 0.125;
        }
      };

      SpaceColony.prototype.followNode = function(node, branches) {
        var child, i, j, len, ref;
        branches[branches.length - 1].push(node.point);
        if (node.children == null) {
          return;
        }
        ref = node.children;
        for (i = j = 0, len = ref.length; j < len; i = ++j) {
          child = ref[i];
          if (i === 0) {
            this.followNode(child, branches);
          } else {
            branches.push([node.point]);
            this.followNode(child, branches);
          }
        }
      };

      SpaceColony.prototype.sendToSpacebrew = function(spacebrew) {
        var base, branches, data, j, json, k, leaves, len, len1, node, ref, ref1;
        json = {};
        leaves = [];
        ref = this.nodes;
        for (j = 0, len = ref.length; j < len; j++) {
          node = ref[j];
          node.children = null;
        }
        ref1 = this.nodes;
        for (k = 0, len1 = ref1.length; k < len1; k++) {
          node = ref1[k];
          if (node.parent != null) {
            if (node.parent === node) {
              continue;
            }
            if ((base = node.parent).children == null) {
              base.children = [];
            }
            node.parent.children.push(node);
          }
        }
        branches = [[]];
        this.followNode(this.nodes[0], branches);
        data = {
          paths: branches,
          scale: this.data.scaleTree,
          bounds: {
            x: this.rectangle.x,
            y: this.rectangle.y,
            width: this.rectangle.width,
            height: this.rectangle.height
          }
        };
        json = JSON.stringify(data);
        console.log(json);
        spacebrew.send("commands", "string", json);
      };

      return SpaceColony;

    })(Shape);
    return SpaceColony;
  });

}).call(this);
