// Generated by CoffeeScript 1.10.0
(function() {
  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  define(['paper', 'R', 'Utils/Utils', 'Items/Paths/Shapes/Shape'], function(P, R, Utils, Shape) {
    var VectorField;
    VectorField = (function(superClass) {
      extend(VectorField, superClass);

      function VectorField() {
        return VectorField.__super__.constructor.apply(this, arguments);
      }

      VectorField.Shape = P.Path.Rectangle;

      VectorField.label = 'Vector field';

      VectorField.description = "Creates a vector field.";

      VectorField.squareByDefault = false;

      VectorField.initializeParameters = function() {
        var parameters;
        parameters = VectorField.__super__.constructor.initializeParameters.call(this);
        parameters['Style'].strokeWidth["default"] = 1;
        parameters['Style'].strokeColor["default"] = 'black';
        parameters['Style'].strokeColor.defaultFunction = null;
        if (parameters['Parameters'] == null) {
          parameters['Parameters'] = {};
        }
        parameters['Parameters'].nLines = {
          type: 'slider',
          label: 'nLines',
          min: 10,
          max: 100,
          "default": 50
        };
        parameters['Parameters'].nLineSteps = {
          type: 'slider',
          label: 'nLineSteps',
          min: 10,
          max: 100,
          "default": 50
        };
        parameters['Parameters'].strength = {
          type: 'slider',
          label: 'strength',
          min: 0,
          max: 1000,
          "default": 300
        };
        parameters['Parameters'].nForces = {
          type: 'slider',
          label: 'nForces',
          min: 1,
          max: 10,
          "default": 3
        };
        parameters['Parameters'].quadratic = {
          type: 'checkbox',
          label: 'quadratic',
          "default": true
        };
        parameters['Parameters'].forceMean = {
          type: 'slider',
          label: 'forceMean',
          min: -100,
          max: 100,
          "default": 0
        };
        parameters['Parameters'].forceSigma = {
          type: 'slider',
          label: 'forceSigma',
          min: 0,
          max: 100,
          "default": 30
        };
        parameters['Parameters'].closestForce = {
          type: 'checkbox',
          label: 'closestForce',
          "default": false
        };
        return parameters;
      };

      VectorField.parameters = VectorField.initializeParameters();

      VectorField.createTool(VectorField);

      VectorField.prototype.initialize = function() {};

      VectorField.prototype.initializeField = function() {
        var circle, i, j, k, l, line, m, ref, ref1, ref2, x, xStep, y, yStep;
        this.forces = [];
        for (i = k = 1, ref = this.data.nForces; 1 <= ref ? k <= ref : k >= ref; i = 1 <= ref ? ++k : --k) {
          circle = this.addPath(new P.Path.Circle(this.rectangle.topLeft.add(this.rectangle.size.multiply(P.Point.random())), 10));
          circle.fillColor = 'white';
          circle.onMouseDrag = (function(_this) {
            return function(event) {
              event.target.position = event.target.position.add(event.delta);
              _this.resetField();
              _this.updateField();
            };
          })(this);
          this.forces.push(circle);
        }
        this.lines = [];
        x = this.rectangle.left;
        y = this.rectangle.top;
        yStep = this.rectangle.height / this.data.nLines;
        xStep = this.rectangle.width / this.data.nLineSteps;
        for (i = l = 1, ref1 = this.data.nLines; 1 <= ref1 ? l <= ref1 : l >= ref1; i = 1 <= ref1 ? ++l : --l) {
          line = this.addPath(new P.Path());
          for (j = m = 1, ref2 = this.data.nLineSteps; 1 <= ref2 ? m <= ref2 : m >= ref2; j = 1 <= ref2 ? ++m : --m) {
            line.add(x, y);
            x += xStep;
          }
          y += yStep;
          x = this.rectangle.left;
          this.lines.push(line);
        }
      };

      VectorField.prototype.resetField = function() {
        var k, l, len, len1, line, ref, ref1, segment, x, xStep, y, yStep;
        x = this.rectangle.left;
        y = this.rectangle.top;
        yStep = this.rectangle.height / this.data.nLines;
        xStep = this.rectangle.width / this.data.nLineSteps;
        ref = this.lines;
        for (k = 0, len = ref.length; k < len; k++) {
          line = ref[k];
          ref1 = line.segments;
          for (l = 0, len1 = ref1.length; l < len1; l++) {
            segment = ref1[l];
            segment.point.x = x;
            segment.point.y = y;
            x += xStep;
          }
          y += yStep;
          x = this.rectangle.left;
        }
      };

      VectorField.prototype.updateField = function() {
        var closestForce, closestForceDistance, direction, force, forceDistance, k, l, len, len1, len2, len3, line, m, n, ref, ref1, ref2, ref3, segment, strength;
        ref = this.lines;
        for (k = 0, len = ref.length; k < len; k++) {
          line = ref[k];
          ref1 = line.segments;
          for (l = 0, len1 = ref1.length; l < len1; l++) {
            segment = ref1[l];
            if (this.data.closestForce) {
              closestForceDistance = 1000000000;
              closestForce = null;
              ref2 = this.forces;
              for (m = 0, len2 = ref2.length; m < len2; m++) {
                force = ref2[m];
                forceDistance = force.position.getDistance(segment.point, true);
                if (forceDistance < closestForceDistance) {
                  closestForceDistance = forceDistance;
                  closestForce = force;
                }
              }
              direction = segment.point.subtract(closestForce.position).normalize();
              if (!this.data.quadratic) {
                closestForceDistance = Math.sqrt(closestForceDistance);
              }
              strength = this.data.strength * Utils.gaussian(this.data.forceMean, this.data.forceSigma, closestForceDistance);
            } else {
              ref3 = this.forces;
              for (n = 0, len3 = ref3.length; n < len3; n++) {
                force = ref3[n];
                direction = segment.point.subtract(force.position);
                strength = this.data.strength * Utils.gaussian(this.data.forceMean, this.data.forceSigma, direction.length);
                direction = direction.normalize();
                segment.point.y += direction.y * strength;
              }
            }
          }
        }
      };

      VectorField.prototype.createShape = function() {
        this.shape = new P.Group();
        this.initializeField();
        this.updateField();
      };

      return VectorField;

    })(Shape);
    return VectorField;
  });

}).call(this);

//# sourceMappingURL=VectorField.js.map
