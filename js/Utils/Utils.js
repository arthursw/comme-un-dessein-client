// Generated by CoffeeScript 1.10.0
(function() {
  define(['paper', 'Utils/CoordinateSystems', 'underscore', 'jquery', 'tinycolor2', 'bootstrap'], function(P, CS, _, $, tinycolor) {
    var Utils, __nativeSI__, __nativeST__, sqrtTwoPi;
    if (typeof window !== "undefined" && window !== null) {
      window.tinycolor = tinycolor;
    }
    if (typeof window !== "undefined" && window !== null) {
      window.P = P;
    }
    Utils = {};
    Utils.CS = CS;
    $.ajaxSetup({
      beforeSend: function(xhr, settings) {
        var getCookie;
        getCookie = function(name) {
          var cookie, cookieValue, cookies, i;
          cookieValue = null;
          if (document.cookie && document.cookie !== '') {
            cookies = document.cookie.split(';');
            i = 0;
            while (i < cookies.length) {
              cookie = jQuery.trim(cookies[i]);
              if (cookie.substring(0, name.length + 1) === name + '=') {
                cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                break;
              }
              i++;
            }
          }
          return cookieValue;
        };
        if (!(/^http:.*/.test(settings.url) || /^https:.*/.test(settings.url))) {
          xhr.setRequestHeader('X-CSRFToken', getCookie('csrftoken'));
        }
      }
    });
    R.commeUnDesseinURL = 'http://localhost:8000/';
    R.me = null;
    R.OSName = "Unknown OS";
    if (navigator.appVersion.indexOf("Win") !== -1) {
      R.OSName = "Windows";
    }
    if (navigator.appVersion.indexOf("Mac") !== -1) {
      R.OSName = "MacOS";
    }
    if (navigator.appVersion.indexOf("X11") !== -1) {
      R.OSName = "UNIX";
    }
    if (navigator.appVersion.indexOf("Linux") !== -1) {
      R.OSName = "Linux";
    }
    R.templatesJ = $("#templates");
    if (document.all && !window.setTimeout.isPolyfill) {
      __nativeST__ = window.setTimeout;
      window.setTimeout = function(vCallback, nDelay) {
        var aArgs;
        aArgs = Array.prototype.slice.call(arguments, 2);
        return __nativeST__((vCallback instanceof Function ? function() {
          return vCallback.apply(null, aArgs);
        } : vCallback), nDelay);
      };
      window.setTimeout.isPolyfill = true;
    }
    if (document.all && !window.setInterval.isPolyfill) {
      __nativeSI__ = window.setInterval;
      window.setInterval = function(vCallback, nDelay) {
        var aArgs;
        aArgs = Array.prototype.slice.call(arguments, 2);
        return __nativeSI__((vCallback instanceof Function ? function() {
          return vCallback.apply(null, aArgs);
        } : vCallback), nDelay);
      };
    }
    window.setInterval.isPolyfill = true;
    Utils.URL = {};
    Utils.URL.getParameters = R.getParameters;
    Utils.URL.setParameters = function(parameters) {
      var hash, name, value;
      hash = '';
      for (name in parameters) {
        value = parameters[name];
        hash += '&' + name + "=" + value;
      }
      hash = hash.replace('&', '');
      return hash;
    };
    Utils.LocalStorage = {};
    Utils.LocalStorage.set = function(key, value) {
      localStorage.setItem(key, JSON.stringify(value));
    };
    Utils.LocalStorage.get = function(key) {
      var value;
      value = localStorage.getItem(key);
      return value && JSON.parse(value);
    };
    Utils.specialKeys = {
      8: 'backspace',
      9: 'tab',
      13: 'enter',
      16: 'shift',
      17: 'control',
      18: 'option',
      19: 'pause',
      20: 'caps-lock',
      27: 'escape',
      32: 'space',
      35: 'end',
      36: 'home',
      37: 'left',
      38: 'up',
      39: 'right',
      40: 'down',
      46: 'delete',
      91: 'command',
      93: 'command',
      224: 'command'
    };
    Utils.createId = function() {
      return ('' + Math.random()).substring(2) + '-' + Date.now();
    };
    Utils.sign = function(x) {
      if (typeof x === "number") {
        if (x) {
          if (x < 0) {
            return -1;
          } else {
            return 1;
          }
        } else {
          if (x === x) {
            return 0;
          } else {
            return NaN;
          }
        }
      } else {
        return NaN;
      }
    };
    Utils.clamp = function(min, value, max) {
      return Math.min(Math.max(value, min), max);
    };
    Utils.random = function(min, max) {
      return min + Math.random() * (max - min);
    };
    Utils.clone = function(object) {
      return $.extend({}, object);
    };
    Utils.Array = {};
    Utils.Array.remove = function(array, itemToRemove) {
      var i;
      if (!Array.prototype.isPrototypeOf(array)) {
        return;
      }
      i = array.indexOf(itemToRemove);
      if (i >= 0) {
        array.splice(i, 1);
      }
    };
    Utils.Array.random = function(array) {
      return array[Math.floor(Math.random() * array.length)];
    };
    Utils.Array.max = function(array) {
      var item, j, len, max;
      max = array[0];
      for (j = 0, len = array.length; j < len; j++) {
        item = array[j];
        if (item > max) {
          max = item;
        }
      }
      return max;
    };
    Utils.Array.min = function(array) {
      var item, j, len, min;
      min = array[0];
      for (j = 0, len = array.length; j < len; j++) {
        item = array[j];
        if (item < min) {
          min = item;
        }
      }
      return min;
    };
    Utils.Array.maxc = function(array, biggerThan) {
      var item, j, len, max;
      max = array[0];
      for (j = 0, len = array.length; j < len; j++) {
        item = array[j];
        if (biggerThan(item, max)) {
          max = item;
        }
      }
      return max;
    };
    Utils.Array.minc = function(array, smallerThan) {
      var item, j, len, min;
      min = array[0];
      for (j = 0, len = array.length; j < len; j++) {
        item = array[j];
        if (smallerThan(item, min)) {
          min = item;
        }
      }
      return min;
    };
    Utils.Array.isArray = function(array) {
      return array.constructor === Array;
    };
    Utils.Array.pushIfAbsent = function(array, item) {
      if (array.indexOf(item) < 0) {
        array.push(item);
      }
    };
    R.updateTimeout = {};
    R.requestedCallbacks = {};
    Utils.deferredExecutionCallbackWrapper = function(callback, id, args, oThis) {
      delete R.updateTimeout[id];
      if (args == null) {
        if (typeof callback === "function") {
          callback();
        }
      } else {
        if (callback != null) {
          callback.apply(oThis, args);
        }
      }
    };
    Utils.deferredExecution = function(callback, id, n, args, oThis) {
      if (n == null) {
        n = 500;
      }
      if (id == null) {
        return;
      }
      if (R.updateTimeout[id] != null) {
        clearTimeout(R.updateTimeout[id]);
      }
      R.updateTimeout[id] = setTimeout(Utils.deferredExecutionCallbackWrapper, n, callback, id, args, oThis);
    };
    Utils.callNextFrame = function(callback, id, args) {
      var base, callbackWrapper;
      if (id == null) {
        id = callback;
      }
      callbackWrapper = function() {
        delete R.requestedCallbacks[id];
        if (args == null) {
          callback();
        } else {
          callback.apply(window, args);
        }
      };
      if ((base = R.requestedCallbacks)[id] == null) {
        base[id] = window.requestAnimationFrame(callbackWrapper);
      }
    };
    Utils.cancelCallNextFrame = function(idToCancel) {
      window.cancelAnimationFrame(R.requestedCallbacks[idToCancel]);
      delete R.requestedCallbacks[idToCancel];
    };
    sqrtTwoPi = Math.sqrt(2 * Math.PI);
    Utils.gaussian = function(mean, sigma, x) {
      var expf;
      expf = -((x - mean) * (x - mean) / (2 * sigma * sigma));
      return (1.0 / (sigma * sqrtTwoPi)) * Math.exp(expf);
    };
    Utils.isEmpty = function(map) {
      var key, value;
      for (key in map) {
        value = map[key];
        if (map.hasOwnProperty(key)) {
          return false;
        }
      }
      return true;
    };
    Utils.capitalizeFirstLetter = function(string) {
      return string.charAt(0).toUpperCase() + string.slice(1);
    };
    Utils.linearInterpolation = function(v1, v2, f) {
      return v1 * (1 - f) + v2 * f;
    };
    Utils.floorToMultiple = function(x, m) {
      return Math.floor(x / m) * m;
    };
    Utils.ceilToMultiple = function(x, m) {
      return Math.ceil(x / m) * m;
    };
    Utils.roundToMultiple = function(x, m) {
      return Math.round(x / m) * m;
    };
    Utils.floorPointToMultiple = function(point, m) {
      return new P.Point(Utils.floorToMultiple(point.x, m), Utils.floorToMultiple(point.y, m));
    };
    Utils.ceilPointToMultiple = function(point, m) {
      return new P.Point(Utils.ceilToMultiple(point.x, m), Utils.ceilToMultiple(point.y, m));
    };
    Utils.roundPointToMultiple = function(point, m) {
      return new P.Point(Utils.roundToMultiple(point.x, m), Utils.roundToMultiple(point.y, m));
    };
    Utils.Rectangle = {};
    Utils.Rectangle.updatePathRectangle = function(path, rectangle) {
      path.segments[0].point = rectangle.bottomLeft;
      path.segments[1].point = rectangle.topLeft;
      path.segments[2].point = rectangle.topRight;
      path.segments[3].point = rectangle.bottomRight;
    };
    Utils.Rectangle.getRotatedBounds = function(rectangle, rotation) {
      var bottomLeft, bottomRight, bounds, topLeft, topRight;
      if (rotation == null) {
        rotation = 0;
      }
      topLeft = rectangle.topLeft.subtract(rectangle.center);
      topLeft.angle += rotation;
      bottomRight = rectangle.bottomRight.subtract(rectangle.center);
      bottomRight.angle += rotation;
      bottomLeft = rectangle.bottomLeft.subtract(rectangle.center);
      bottomLeft.angle += rotation;
      topRight = rectangle.topRight.subtract(rectangle.center);
      topRight.angle += rotation;
      bounds = new P.Rectangle(rectangle.center.add(topLeft), rectangle.center.add(bottomRight));
      bounds = bounds.include(rectangle.center.add(bottomLeft));
      bounds = bounds.include(rectangle.center.add(topRight));
      return bounds;
    };
    Utils.Rectangle.shrinkRectangleToInteger = function(rectangle) {
      return new P.Rectangle(rectangle.topLeft.ceil(), rectangle.bottomRight.floor());
    };
    Utils.Rectangle.expandRectangleToInteger = function(rectangle) {
      return new P.Rectangle(rectangle.topLeft.floor(), rectangle.bottomRight.ceil());
    };
    Utils.Rectangle.expandRectangleToMultiple = function(rectangle, multiple) {
      return new P.Rectangle(Utils.floorPointToMultiple(rectangle.topLeft, multiple), Utils.ceilPointToMultiple(rectangle.bottomRight, multiple));
    };
    Utils.Rectangle.roundRectangle = function(rectangle) {
      return new P.Rectangle(rectangle.topLeft.round(), rectangle.bottomRight.round());
    };
    P.Point.prototype.toJSON = function() {
      return {
        x: this.x,
        y: this.y
      };
    };
    P.Point.prototype.exportJSON = function() {
      return JSON.stringify(this.toJSON());
    };
    P.Rectangle.prototype.toJSON = function() {
      return {
        x: this.x,
        y: this.y,
        width: this.width,
        height: this.height
      };
    };
    P.Rectangle.prototype.exportJSON = function() {
      return JSON.stringify(this.toJSON());
    };
    P.Rectangle.prototype.translate = function(point) {
      return new P.Rectangle(this.x + point.x, this.y + point.y, this.width, this.height);
    };
    P.Rectangle.prototype.scaleFromCenter = function(scale, center) {
      var delta, topLeft;
      delta = this.topLeft.subtract(center);
      delta = delta.multiply(scale.x, scale.y);
      topLeft = center.add(delta);
      return new P.Rectangle(topLeft, new P.Size(this.width * scale.x, this.height * scale.y));
    };
    P.Rectangle.prototype.moveSide = function(sideName, destination) {
      switch (sideName) {
        case 'left':
          this.x = destination;
          break;
        case 'right':
          this.x = destination - this.width;
          break;
        case 'top':
          this.y = destination;
          break;
        case 'bottom':
          this.y = destination - this.height;
      }
    };
    P.Rectangle.prototype.moveCorner = function(cornerName, destination) {
      switch (cornerName) {
        case 'topLeft':
          this.x = destination.x;
          this.y = destination.y;
          break;
        case 'topRight':
          this.x = destination.x - this.width;
          this.y = destination.y;
          break;
        case 'bottomRight':
          this.x = destination.x - this.width;
          this.y = destination.y - this.height;
          break;
        case 'bottomLeft':
          this.x = destination.x;
          this.y = destination.y - this.height;
      }
    };
    P.Rectangle.prototype.moveCenter = function(destination) {
      this.x = destination.x - this.width * 0.5;
      this.y = destination.y - this.height * 0.5;
    };
    P.Event.prototype.toJSON = function() {
      var event;
      event = {
        modifiers: this.modifiers,
        event: {
          which: this.event.which
        },
        point: this.point,
        downPoint: this.downPoint,
        delta: this.delta,
        middlePoint: this.middlePoint,
        type: this.type,
        count: this.count
      };
      return event;
    };
    P.Event.prototype.fromJSON = function(event) {
      if (event.point != null) {
        event.point = new P.Point(event.point);
      }
      if (event.downPoint != null) {
        event.downPoint = new P.Point(event.downPoint);
      }
      if (event.delta != null) {
        event.delta = new P.Point(event.delta);
      }
      if (event.middlePoint != null) {
        event.middlePoint = new P.Point(event.middlePoint);
      }
      return event;
    };
    Utils.Event = {};
    Utils.Event.GetPoint = function(event) {
      if ((event.originalEvent != null) && (typeof TouchEvent !== "undefined" && TouchEvent !== null) && event.originalEvent instanceof TouchEvent) {
        return new P.Point(event.originalEvent.touches[0].pageX, event.originalEvent.touches[0].pageY);
      } else {
        return new P.Point(event.pageX, event.pageY);
      }
    };
    Utils.Event.jEventToPoint = function(event) {
      var point;
      point = Utils.Event.GetPoint(event);
      return P.view.viewToProject(new P.Point(point.x - R.canvasJ.offset().left, point.y - R.canvasJ.offset().top));
    };
    Utils.Event.jEventToPaperEvent = function(event, previousPosition, initialPosition, type, count) {
      var currentPosition, delta, paperEvent;
      if (previousPosition == null) {
        previousPosition = null;
      }
      if (initialPosition == null) {
        initialPosition = null;
      }
      if (type == null) {
        type = null;
      }
      if (count == null) {
        count = null;
      }
      currentPosition = Utils.Event.jEventToPoint(event);
      if (previousPosition == null) {
        previousPosition = currentPosition;
      }
      if (initialPosition == null) {
        initialPosition = currentPosition;
      }
      delta = currentPosition.subtract(previousPosition);
      paperEvent = {
        modifiers: {
          shift: event.shiftKey,
          control: event.ctrlKey,
          option: event.altKey,
          command: event.metaKey
        },
        point: currentPosition,
        downPoint: initialPosition,
        delta: delta,
        middlePoint: previousPosition.add(delta.divide(2)),
        type: type,
        count: count
      };
      return paperEvent;
    };
    R.specialKey = function(event) {
      var specialKey;
      if (event instanceof Event) {
        specialKey = R.OSName === "MacOS" ? event.metaKey : event.ctrlKey;
      } else {
        specialKey = R.OSName === "MacOS" ? event.modifiers.command : event.modifiers.control;
      }
      return specialKey;
    };
    Utils.Snap = {};
    Utils.Snap.getSnap = function() {
      return R.parameters.General.snap.value;
    };
    Utils.Snap.snap = function(event, from) {
      var snap, snappedEvent;
      if (from == null) {
        from = R.me;
      }
      if (from !== R.me) {
        return event;
      }
      if (R.selectedTool.disableSnap()) {
        return event;
      }
      snap = R.parameters.General.snap.value;
      if (snap !== 0) {
        snappedEvent = jQuery.extend({}, event);
        snappedEvent.modifiers = event.modifiers;
        snappedEvent.point = Utils.Snap.snap2D(event.point, snap);
        if (event.lastPoint != null) {
          snappedEvent.lastPoint = Utils.Snap.snap2D(event.lastPoint, snap);
        }
        if (event.downPoint != null) {
          snappedEvent.downPoint = Utils.Snap.snap2D(event.downPoint, snap);
        }
        if (event.lastPoint != null) {
          snappedEvent.middlePoint = snappedEvent.point.add(snappedEvent.lastPoint).multiply(0.5);
        }
        if (event.type !== 'mouseup' && (event.lastPoint != null)) {
          snappedEvent.delta = snappedEvent.point.subtract(snappedEvent.lastPoint);
        } else if (event.downPoint != null) {
          snappedEvent.delta = snappedEvent.point.subtract(snappedEvent.downPoint);
        }
        return snappedEvent;
      } else {
        return event;
      }
    };
    Utils.Snap.snap1D = function(value, snap) {
      if (snap == null) {
        snap = Utils.Snap.getSnap();
      }
      if (snap !== 0) {
        return Math.round(value / snap) * snap;
      } else {
        return value;
      }
    };
    Utils.Snap.snap2D = function(point, snap) {
      if (snap == null) {
        snap = Utils.Snap.getSnap();
      }
      if (snap !== 0) {
        return new P.Point(Utils.Snap.snap1D(point.x, snap), Utils.Snap.snap1D(point.y, snap));
      } else {
        return point;
      }
    };
    Utils.Animation = {};
    Utils.Animation.registerAnimation = function(item) {
      Utils.Array.pushIfAbsent(R.animatedItems, item);
    };
    Utils.Animation.deregisterAnimation = function(item) {
      Utils.Array.remove(R.animatedItems, item);
    };
    Utils.stringToPoint = function(string) {
      var p, pos;
      pos = string.split(',');
      p = new P.Point(parseFloat(pos[0]), parseFloat(pos[1]));
      if (!_.isFinite(p.x)) {
        p.x = 0;
      }
      if (!_.isFinite(p.y)) {
        p.y = 0;
      }
      return p;
    };
    Utils.pointToString = function(point, precision) {
      if (precision == null) {
        precision = 2;
      }
      return point.x.toFixed(precision) + ',' + point.y.toFixed(precision);
    };
    Utils.logElapsedTime = function() {
      var time;
      time = (Date.now() - R.startTime) / 1000;
      console.log("Time elapsed: " + time + " sec.");
    };
    Utils.defaultCallback = function(a) {
      console.log(a);
    };
    Utils.defineRequireJsModule = function(moduleName, resultName) {
      require([moduleName], function(result) {
        return window[resultName] = result;
      });
    };
    return Utils;
  });

}).call(this);
